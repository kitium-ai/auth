/**
 * In-memory storage adapter
 * Development and testing adapter that stores data in memory
 */

import {
  StorageAdapter,
  ApiKeyRecord,
  SessionRecord,
  UserRecord,
  CreateUserInput,
  UpdateUserInput,
  OrganizationRecord,
  EmailVerificationToken,
  AuthEvent,
  OAuthLink,
} from '../types';

/**
 * In-memory storage adapter implementation
 */
export class MemoryStorageAdapter implements StorageAdapter {
  private users = new Map<string, UserRecord>();
  private usersByEmail = new Map<string, UserRecord>();
  private usersByOAuth = new Map<string, UserRecord>();
  private sessions = new Map<string, SessionRecord>();
  private apiKeys = new Map<string, ApiKeyRecord>();
  private apiKeysByHash = new Map<string, ApiKeyRecord>();
  private organizations = new Map<string, OrganizationRecord>();
  private roles = new Map<string, any>();
  private twoFactorDevices = new Map<string, any>();
  private backupCodes = new Map<string, any[]>();
  private emailVerificationTokens = new Map<string, EmailVerificationToken>();
  private emailTokenAttempts = new Map<string, number>();
  private ssoProviders = new Map<string, any>();
  private ssoLinks = new Map<string, any>();
  private ssoSessions = new Map<string, any>();
  private tenantSAMLConfigs = new Map<string, any>();
  private userRoles = new Map<string, string[]>();
  private twoFactorSessions = new Map<string, any>();
  private events: AuthEvent[] = [];

  async connect(): Promise<void> {
    // No-op for memory adapter
  }

  async disconnect(): Promise<void> {
    // Clear all data on disconnect
    this.users.clear();
    this.usersByEmail.clear();
    this.usersByOAuth.clear();
    this.sessions.clear();
    this.apiKeys.clear();
    this.apiKeysByHash.clear();
    this.organizations.clear();
    this.roles.clear();
    this.twoFactorDevices.clear();
    this.backupCodes.clear();
    this.emailVerificationTokens.clear();
    this.emailTokenAttempts.clear();
    this.ssoProviders.clear();
    this.ssoLinks.clear();
    this.ssoSessions.clear();
    this.tenantSAMLConfigs.clear();
    this.userRoles.clear();
    this.twoFactorSessions.clear();
    this.events = [];
  }

  // ===== API Keys =====
  async createApiKey(data: Omit<ApiKeyRecord, 'id' | 'createdAt'>): Promise<ApiKeyRecord> {
    const record: ApiKeyRecord = {
      id: `key_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.apiKeys.set(record.id, record);
    this.apiKeysByHash.set(record.hash, record);
    return record;
  }

  async getApiKey(id: string): Promise<ApiKeyRecord | null> {
    return this.apiKeys.get(id) || null;
  }

  async getApiKeyByHash(hash: string): Promise<ApiKeyRecord | null> {
    return this.apiKeysByHash.get(hash) || null;
  }

  async getApiKeysByPrefixAndLastFour(prefix: string, lastFour: string): Promise<ApiKeyRecord[]> {
    return Array.from(this.apiKeys.values()).filter(
      (k) => k.prefix === prefix && k.lastFour === lastFour
    );
  }

  async updateApiKey(id: string, data: Partial<ApiKeyRecord>): Promise<ApiKeyRecord> {
    const key = this.apiKeys.get(id);
    if (!key) throw new Error(`API key ${id} not found`);

    const updated: ApiKeyRecord = {
      ...key,
      ...data,
      id: key.id,
      createdAt: key.createdAt,
      updatedAt: new Date(),
    };

    this.apiKeys.set(id, updated);
    if (data.hash) {
      this.apiKeysByHash.delete(key.hash);
      this.apiKeysByHash.set(data.hash, updated);
    }
    return updated;
  }

  async deleteApiKey(id: string): Promise<void> {
    const key = this.apiKeys.get(id);
    if (key) {
      this.apiKeys.delete(id);
      this.apiKeysByHash.delete(key.hash);
    }
  }

  async listApiKeys(principalId: string): Promise<ApiKeyRecord[]> {
    return Array.from(this.apiKeys.values()).filter((k) => k.principalId === principalId);
  }

  // ===== Sessions =====
  async createSession(data: Omit<SessionRecord, 'id' | 'createdAt'>): Promise<SessionRecord> {
    const record: SessionRecord = {
      id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.sessions.set(record.id, record);
    return record;
  }

  async getSession(id: string): Promise<SessionRecord | null> {
    const session = this.sessions.get(id);
    if (session && new Date() > session.expiresAt) {
      this.sessions.delete(id);
      return null;
    }
    return session || null;
  }

  async updateSession(id: string, data: Partial<SessionRecord>): Promise<SessionRecord> {
    const session = this.sessions.get(id);
    if (!session) throw new Error(`Session ${id} not found`);

    const updated: SessionRecord = {
      ...session,
      ...data,
      id: session.id,
      createdAt: session.createdAt,
      updatedAt: new Date(),
    };

    this.sessions.set(id, updated);
    return updated;
  }

  async deleteSession(id: string): Promise<void> {
    this.sessions.delete(id);
  }

  // ===== Organizations =====
  async createOrganization(
    data: Omit<OrganizationRecord, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<OrganizationRecord> {
    const record: OrganizationRecord = {
      id: `org_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.organizations.set(record.id, record);
    return record;
  }

  async getOrganization(id: string): Promise<OrganizationRecord | null> {
    return this.organizations.get(id) || null;
  }

  async updateOrganization(
    id: string,
    data: Partial<OrganizationRecord>
  ): Promise<OrganizationRecord> {
    const org = this.organizations.get(id);
    if (!org) throw new Error(`Organization ${id} not found`);

    const updated: OrganizationRecord = {
      ...org,
      ...data,
      id: org.id,
      createdAt: org.createdAt,
      updatedAt: new Date(),
    };

    this.organizations.set(id, updated);
    return updated;
  }

  async deleteOrganization(id: string): Promise<void> {
    this.organizations.delete(id);
  }

  // ===== Users =====
  async createUser(data: CreateUserInput): Promise<UserRecord> {
    const record: UserRecord = {
      id: `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      entitlements: data.entitlements || [],
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.users.set(record.id, record);
    if (record.email) {
      this.usersByEmail.set(record.email.toLowerCase(), record);
    }
    return record;
  }

  async getUser(id: string): Promise<UserRecord | null> {
    return this.users.get(id) || null;
  }

  async getUserByEmail(email: string): Promise<UserRecord | null> {
    return this.usersByEmail.get(email.toLowerCase()) || null;
  }

  async getUserByOAuth(provider: string, sub: string): Promise<UserRecord | null> {
    const key = `${provider}:${sub}`;
    return this.usersByOAuth.get(key) || null;
  }

  async updateUser(id: string, data: UpdateUserInput): Promise<UserRecord> {
    const user = this.users.get(id);
    if (!user) throw new Error(`User ${id} not found`);

    const updated: UserRecord = {
      ...user,
      ...data,
      entitlements: data.entitlements || user.entitlements,
      id: user.id,
      createdAt: user.createdAt,
      updatedAt: new Date(),
    };

    this.users.set(id, updated);

    // Update email index
    if (data.email && data.email !== user.email) {
      if (user.email) {
        this.usersByEmail.delete(user.email.toLowerCase());
      }
      this.usersByEmail.set(data.email.toLowerCase(), updated);
    }

    return updated;
  }

  async deleteUser(id: string): Promise<void> {
    const user = this.users.get(id);
    if (user && user.email) {
      this.usersByEmail.delete(user.email.toLowerCase());
    }
    this.users.delete(id);

    // Clean up related data
    this.backupCodes.delete(id);
    this.userRoles.delete(id);
    Array.from(this.usersByOAuth.entries()).forEach(([key, u]) => {
      if (u.id === id) {
        this.usersByOAuth.delete(key);
      }
    });
  }

  async linkOAuthAccount(
    userId: string,
    provider: string,
    oauthLink: OAuthLink
  ): Promise<UserRecord> {
    const user = this.users.get(userId);
    if (!user) throw new Error(`User ${userId} not found`);

    if (!user.oauth) {
      user.oauth = {};
    }

    user.oauth[provider] = oauthLink;
    const key = `${provider}:${oauthLink.sub}`;
    this.usersByOAuth.set(key, user);

    return user;
  }

  // ===== Email Verification Tokens =====
  async createEmailVerificationToken(
    data: Omit<EmailVerificationToken, 'id'>
  ): Promise<EmailVerificationToken> {
    const record: EmailVerificationToken = {
      id: `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date(),
    };

    this.emailVerificationTokens.set(record.id, record);
    this.emailTokenAttempts.set(record.id, 0);
    return record;
  }

  async getEmailVerificationTokens(
    email: string,
    type?: string
  ): Promise<EmailVerificationToken[]> {
    const tokens = Array.from(this.emailVerificationTokens.values()).filter(
      (t) => t.email.toLowerCase() === email.toLowerCase() && (!type || t.type === type)
    );

    return tokens.filter((t) => !t.usedAt && new Date() < t.expiresAt);
  }

  async getEmailVerificationTokenById(id: string): Promise<EmailVerificationToken | null> {
    const token = this.emailVerificationTokens.get(id);
    if (!token) return null;

    if (new Date() > token.expiresAt) {
      this.emailVerificationTokens.delete(id);
      return null;
    }

    return token;
  }

  async markEmailVerificationTokenAsUsed(id: string): Promise<EmailVerificationToken> {
    const token = this.emailVerificationTokens.get(id);
    if (!token) throw new Error(`Token ${id} not found`);

    token.usedAt = new Date();
    return token;
  }

  async deleteExpiredEmailVerificationTokens(): Promise<number> {
    const now = new Date();
    let count = 0;

    for (const [id, token] of this.emailVerificationTokens.entries()) {
      if (now > token.expiresAt) {
        this.emailVerificationTokens.delete(id);
        this.emailTokenAttempts.delete(id);
        count++;
      }
    }

    return count;
  }

  async getEmailVerificationTokenAttempts(tokenId: string): Promise<number> {
    return this.emailTokenAttempts.get(tokenId) || 0;
  }

  async incrementEmailVerificationTokenAttempts(tokenId: string): Promise<number> {
    const current = this.emailTokenAttempts.get(tokenId) || 0;
    const updated = current + 1;
    this.emailTokenAttempts.set(tokenId, updated);
    return updated;
  }

  // ===== SAML Configuration =====
  async storeTenantSAMLConfig(config: any): Promise<void> {
    this.tenantSAMLConfigs.set(config.tenantId, config);
  }

  async getTenantSAMLConfig(tenantId: string): Promise<any | null> {
    return this.tenantSAMLConfigs.get(tenantId) || null;
  }

  async updateTenantSAMLConfig(tenantId: string, updates: Partial<any>): Promise<void> {
    const config = this.tenantSAMLConfigs.get(tenantId);
    if (!config) throw new Error(`SAML config for tenant ${tenantId} not found`);
    this.tenantSAMLConfigs.set(tenantId, { ...config, ...updates });
  }

  async deleteTenantSAMLConfig(tenantId: string): Promise<void> {
    this.tenantSAMLConfigs.delete(tenantId);
  }

  // ===== RBAC =====
  async createRole(data: Omit<any, 'id' | 'createdAt' | 'updatedAt'>): Promise<any> {
    const role = {
      id: `role_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.roles.set(role.id, role);
    return role;
  }

  async getRole(roleId: string): Promise<any | null> {
    return this.roles.get(roleId) || null;
  }

  async updateRole(roleId: string, data: Partial<any>): Promise<any> {
    const role = this.roles.get(roleId);
    if (!role) throw new Error(`Role ${roleId} not found`);

    const updated = {
      ...role,
      ...data,
      id: role.id,
      createdAt: role.createdAt,
      updatedAt: new Date(),
    };
    this.roles.set(roleId, updated);
    return updated;
  }

  async deleteRole(roleId: string): Promise<void> {
    this.roles.delete(roleId);
  }

  async listRoles(orgId: string): Promise<any[]> {
    return Array.from(this.roles.values()).filter((r) => r.orgId === orgId);
  }

  async assignRoleToUser(userId: string, roleId: string, orgId: string): Promise<any> {
    const role = this.roles.get(roleId);
    if (!role) throw new Error(`Role ${roleId} not found`);

    const key = `${userId}:${orgId}`;
    const roles = this.userRoles.get(key) || [];
    if (!roles.includes(roleId)) {
      roles.push(roleId);
      this.userRoles.set(key, roles);
    }

    return role;
  }

  async revokeRoleFromUser(userId: string, roleId: string, orgId: string): Promise<void> {
    const key = `${userId}:${orgId}`;
    const roles = this.userRoles.get(key) || [];
    const index = roles.indexOf(roleId);
    if (index > -1) {
      roles.splice(index, 1);
      this.userRoles.set(key, roles);
    }
  }

  async getUserRoles(userId: string, orgId: string): Promise<any[]> {
    const key = `${userId}:${orgId}`;
    const roleIds = this.userRoles.get(key) || [];
    return roleIds.map((id) => this.roles.get(id)).filter((r) => r !== undefined);
  }

  // ===== 2FA =====
  async createTwoFactorDevice(data: any): Promise<any> {
    const device = {
      id: `2fa_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date(),
    };

    this.twoFactorDevices.set(device.id, device);
    return device;
  }

  async getTwoFactorDevice(deviceId: string): Promise<any | null> {
    return this.twoFactorDevices.get(deviceId) || null;
  }

  async updateTwoFactorDevice(deviceId: string, data: Partial<any>): Promise<any> {
    const device = this.twoFactorDevices.get(deviceId);
    if (!device) throw new Error(`2FA device ${deviceId} not found`);

    const updated = { ...device, ...data, id: device.id, createdAt: device.createdAt };
    this.twoFactorDevices.set(deviceId, updated);
    return updated;
  }

  async listTwoFactorDevices(userId: string): Promise<any[]> {
    return Array.from(this.twoFactorDevices.values()).filter((d) => d.userId === userId);
  }

  async deleteTwoFactorDevice(deviceId: string): Promise<void> {
    this.twoFactorDevices.delete(deviceId);
  }

  async createBackupCodes(userId: string, codes: any[]): Promise<any[]> {
    this.backupCodes.set(userId, codes);
    return codes;
  }

  async getBackupCodes(userId: string): Promise<any[]> {
    return this.backupCodes.get(userId) || [];
  }

  async markBackupCodeUsed(codeId: string): Promise<void> {
    for (const codes of this.backupCodes.values()) {
      const code = codes.find((c) => c.id === codeId);
      if (code) {
        code.used = true;
      }
    }
  }

  async createTwoFactorSession(data: any): Promise<any> {
    const session = {
      id: `2fa_session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date(),
    };

    this.twoFactorSessions.set(session.id, session);
    return session;
  }

  async getTwoFactorSession(sessionId: string): Promise<any | null> {
    return this.twoFactorSessions.get(sessionId) || null;
  }

  async completeTwoFactorSession(sessionId: string): Promise<void> {
    this.twoFactorSessions.delete(sessionId);
  }

  // ===== SSO =====
  async createSSOProvider(data: any): Promise<any> {
    const provider = {
      id: `sso_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date(),
    };

    this.ssoProviders.set(provider.id, provider);
    return provider;
  }

  async getSSOProvider(providerId: string): Promise<any | null> {
    return this.ssoProviders.get(providerId) || null;
  }

  async updateSSOProvider(providerId: string, data: Partial<any>): Promise<any> {
    const provider = this.ssoProviders.get(providerId);
    if (!provider) throw new Error(`SSO provider ${providerId} not found`);

    const updated = { ...provider, ...data, id: provider.id, createdAt: provider.createdAt };
    this.ssoProviders.set(providerId, updated);
    return updated;
  }

  async deleteSSOProvider(providerId: string): Promise<void> {
    this.ssoProviders.delete(providerId);
  }

  async listSSOProviders(orgId?: string): Promise<any[]> {
    const providers = Array.from(this.ssoProviders.values());
    return orgId ? providers.filter((p) => p.orgId === orgId) : providers;
  }

  async createSSOLink(data: any): Promise<any> {
    const link = {
      id: `sso_link_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date(),
    };

    this.ssoLinks.set(link.id, link);
    return link;
  }

  async getSSOLink(linkId: string): Promise<any | null> {
    return this.ssoLinks.get(linkId) || null;
  }

  async getUserSSOLinks(userId: string): Promise<any[]> {
    return Array.from(this.ssoLinks.values()).filter((l) => l.userId === userId);
  }

  async deleteSSOLink(linkId: string): Promise<void> {
    this.ssoLinks.delete(linkId);
  }

  async createSSOSession(data: any): Promise<any> {
    const session = {
      id: `sso_session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ...data,
      createdAt: new Date(),
    };

    this.ssoSessions.set(session.id, session);
    return session;
  }

  async getSSOSession(sessionId: string): Promise<any | null> {
    return this.ssoSessions.get(sessionId) || null;
  }

  // ===== Events =====
  async emitEvent(event: AuthEvent): Promise<void> {
    this.events.push(event);
  }

  // ===== Helper Methods =====
  /**
   * Get all events (useful for testing)
   */
  getEvents(): AuthEvent[] {
    return [...this.events];
  }

  /**
   * Clear all events (useful for testing)
   */
  clearEvents(): void {
    this.events = [];
  }

  /**
   * Get event count by type (useful for testing)
   */
  getEventCount(type: string): number {
    return this.events.filter((e) => e.type === type).length;
  }
}

export function BillingPortal(_props: any) {
  return null;
}

export function SignIn(_props: any) {
  return null;
}

export function UserMenu(_props: any) {
  return null;
}

/**
 * Email providers
 */

export interface EmailProvider {
  send(to: string, subject: string, html: string): Promise<void>;
}

export class SMTPEmailProvider implements EmailProvider {
  async send(_to: string, _subject: string, _html: string): Promise<void> {}
}

export class SendGridEmailProvider implements EmailProvider {
  async send(_to: string, _subject: string, _html: string): Promise<void> {}
}

export class MailgunEmailProvider implements EmailProvider {
  async send(_to: string, _subject: string, _html: string): Promise<void> {}
}

export class ResendEmailProvider implements EmailProvider {
  async send(_to: string, _subject: string, _html: string): Promise<void> {}
}

export class MockEmailProvider implements EmailProvider {
  async send(_to: string, _subject: string, _html: string): Promise<void> {}
}

export async function createEmailProvider(_config: any): Promise<EmailProvider> {
  return new MockEmailProvider();
}

/**
 * Email authentication routes
 */

export async function createEmailRoutes() {
  return [];
}

/**
 * Email authentication service
 */

import { getLogger } from '@kitiumai/logger';

const logger = getLogger();

export class EmailAuthService {
  async sendVerificationEmail(email: string): Promise<void> {
    logger.debug('Sending verification email', { email });
  }

  async sendPasswordResetEmail(email: string): Promise<void> {
    logger.debug('Sending password reset email', { email });
  }
}

/**
 * Email templates
 */

export function createPasswordResetTemplate(link: string): string {
  return `<a href="${link}">Reset Password</a>`;
}

export function createEmailVerificationTemplate(link: string): string {
  return `<a href="${link}">Verify Email</a>`;
}

export function createVerificationCodeTemplate(code: string): string {
  return `<p>Your code: ${code}</p>`;
}

export function createLoginLinkTemplate(link: string): string {
  return `<a href="${link}">Login</a>`;
}

export function createWelcomeTemplate(name: string): string {
  return `<p>Welcome, ${name}!</p>`;
}

export class EmailVerificationManager {
  async generateVerificationLink() {
    return '';
  }
  async generateResetLink() {
    return '';
  }
  async generateLoginLink() {
    return '';
  }
}

export async function generateVerificationLink() {
  return '';
}
export async function generateResetLink() {
  return '';
}
export async function generateLoginLink() {
  return '';
}

import { Request, Response, NextFunction } from 'express';
import { getLogger } from '@kitiumai/logger';
import { TwoFactorAuthService } from '../twofa/service';
import { AuthenticationError, ValidationError } from '../errors';

/**
 * 2FA Middleware for Express.js
 * Enforces two-factor authentication for protected routes
 */

export interface TwoFAMiddlewareOptions {
  twoFAService: TwoFactorAuthService;
  skipRoutes?: string[]; // Routes that don't require 2FA
  rememberDeviceDays?: number; // Days to remember device (default: 30)
}

/**
 * Require 2FA for route access
 */
export function require2FA(options: TwoFAMiddlewareOptions) {
  const logger = getLogger();
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      if (!user || !user.id) {
        logger.warn('2FA required but user not authenticated', { path: req.path });
        throw new AuthenticationError({
          code: 'auth/user_not_authenticated',
          message: 'User not authenticated',
          severity: 'error',
          retryable: false,
        });
      }

      // Check if route should skip 2FA check
      if (options.skipRoutes?.some((route) => req.path.startsWith(route))) {
        return next();
      }

      // Get user's 2FA status
      const twoFAStatus = await options.twoFAService.getTwoFactorStatus(user.id);

      if (!twoFAStatus.enabled) {
        // 2FA not enrolled, skip for now (can be enforced per org)
        return next();
      }

      // Check if 2FA session is already completed
      const twoFASessionId = req.cookies?.['_tfa_session'];
      if (twoFASessionId) {
        // Verify session is still valid
        const twoFASession = await options.twoFAService.getTwoFactorSession?.(twoFASessionId);
        if (twoFASession && twoFASession.completedAt && new Date() < twoFASession.expiresAt) {
          // 2FA already completed in this session
          return next();
        }
      }

      // User requires 2FA but hasn't completed it yet
      res.status(401).json({
        error: 'Two-factor authentication required',
        code: 'TFA_REQUIRED',
        userId: user.id,
        devices: twoFAStatus.devices.map((d) => ({
          id: d.id,
          method: d.method,
          name: d.name,
          verified: d.verified,
        })),
      });
    } catch (error) {
      res.status(401).json({ error: 'Unauthorized' });
    }
  };
}

/**
 * Verify 2FA code during authentication
 */
export function verify2FACode(options: TwoFAMiddlewareOptions) {
  const logger = getLogger();
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { userId, deviceId, code, rememberDevice } = req.body;

      if (!userId || !deviceId || !code) {
        logger.warn('2FA verification attempted with missing fields', { userId, deviceId });
        throw new ValidationError({
          code: 'auth/missing_2fa_fields',
          message: 'Missing required fields: userId, deviceId, code',
          severity: 'error',
          retryable: false,
          context: { userId, deviceId, hasCode: !!code },
        });
      }

      logger.debug('Verifying 2FA code', { userId });

      // Verify the 2FA code
      const isValid = await options.twoFAService.verifyTwoFactor(userId, deviceId, code);

      if (!isValid) {
        return res.status(401).json({
          error: 'Invalid 2FA code',
          code: 'INVALID_2FA_CODE',
        });
      }

      // Create 2FA session if verification succeeds
      const sessionId = req.cookies?.['session_id'] || `session_${Date.now()}`;
      const twoFASession = await options.twoFAService.createTwoFactorSession(
        userId,
        sessionId,
        deviceId
      );

      if (twoFASession) {
        await options.twoFAService.completeTwoFactorSession(twoFASession.id);
      }

      // Set 2FA session cookie
      const rememberDays = rememberDevice ? options.rememberDeviceDays || 30 : 0;
      const maxAge = rememberDays > 0 ? rememberDays * 24 * 60 * 60 * 1000 : undefined;

      res.cookie('_tfa_session', twoFASession?.id, {
        httpOnly: true,
        secure: process.env['NODE_ENV'] === 'production',
        sameSite: 'strict',
        maxAge,
      });

      (req as any).user = {
        ...(req as any).user,
        twoFAVerified: true,
        twoFASessionId: twoFASession?.id,
        rememberDeviceUntil: rememberDays > 0 ? new Date(Date.now() + maxAge!) : undefined,
      };

      next();
    } catch (error) {
      res.status(401).json({ error: 'Failed to verify 2FA' });
    }
  };
}

/**
 * Initiate 2FA enrollment
 */
export function initiate2FAEnrollment(options: TwoFAMiddlewareOptions) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      if (!user || !user.id) {
        throw new AuthenticationError({
          code: 'auth/user_not_authenticated',
          message: 'User not authenticated',
          severity: 'error',
          retryable: false,
        });
      }

      const { method, phoneNumber, name } = req.body;

      if (!method || !['totp', 'sms'].includes(method)) {
        throw new ValidationError({
          code: 'auth/invalid_2fa_method',
          message: 'Invalid 2FA method',
          severity: 'error',
          retryable: false,
          context: { method },
        });
      }

      if (method === 'sms' && !phoneNumber) {
        throw new ValidationError({
          code: 'auth/phone_number_required',
          message: 'Phone number required for SMS 2FA',
          severity: 'error',
          retryable: false,
        });
      }

      let device;
      if (method === 'totp') {
        device = await options.twoFAService.enrollTOTPDevice(user.id, name);
      } else if (method === 'sms') {
        device = await options.twoFAService.enrollSMSDevice(user.id, phoneNumber, name);
        // Send verification code
        await options.twoFAService.sendSMSCode(device.id);
      }

      res.json({
        success: true,
        device: {
          id: device.id,
          method: device.method,
          name: device.name,
          verified: device.verified,
        },
        ...(method === 'totp' && { qrCode: (device as any).qrCode }),
      });
    } catch (error) {
      res.status(400).json({ error: 'Failed to initiate 2FA enrollment' });
    }
  };
}

/**
 * Complete 2FA enrollment
 */
export function complete2FAEnrollment(options: TwoFAMiddlewareOptions) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      if (!user || !user.id) {
        throw new AuthenticationError({
          code: 'auth/user_not_authenticated',
          message: 'User not authenticated',
          severity: 'error',
          retryable: false,
        });
      }

      const { deviceId, code } = req.body;

      if (!deviceId || !code) {
        throw new ValidationError({
          code: 'auth/missing_2fa_enrollment_fields',
          message: 'Missing required fields: deviceId, code',
          severity: 'error',
          retryable: false,
          context: { deviceId, hasCode: !!code },
        });
      }

      let backupCodes;
      const device = await options.twoFAService.getDevice(deviceId);

      if (device?.method === 'totp') {
        backupCodes = await options.twoFAService.verifyTOTPEnrollment(user.id, deviceId, code);
      } else if (device?.method === 'sms') {
        await options.twoFAService.verifySMSCode(user.id, deviceId, code);
      }

      res.json({
        success: true,
        device: {
          id: device?.id,
          method: device?.method,
          verified: true,
        },
        backupCodes: backupCodes?.map((bc) => ({
          id: bc.id,
          code: bc.code, // Show plaintext only once during enrollment
        })),
      });
    } catch (error) {
      res.status(400).json({ error: 'Failed to complete 2FA enrollment' });
    }
  };
}

/**
 * List user's 2FA devices
 */
export function list2FADevices(options: TwoFAMiddlewareOptions) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      if (!user || !user.id) {
        throw new AuthenticationError({
          code: 'auth/user_not_authenticated',
          message: 'User not authenticated',
          severity: 'error',
          retryable: false,
        });
      }

      const devices = await options.twoFAService.listDevices(user.id);
      const status = await options.twoFAService.getTwoFactorStatus(user.id);

      res.json({
        enabled: status.enabled,
        enrolledAt: status.enrolledAt,
        devices: devices.map((d) => ({
          id: d.id,
          method: d.method,
          name: d.name,
          verified: d.verified,
          lastUsedAt: d.lastUsedAt,
        })),
        backupCodesCount: status.backupCodesCount,
        backupCodesUsedCount: status.backupCodesUsedCount,
      });
    } catch (error) {
      res.status(400).json({ error: 'Failed to list 2FA devices' });
    }
  };
}

/**
 * Delete a 2FA device
 */
export function delete2FADevice(options: TwoFAMiddlewareOptions) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      if (!user || !user.id) {
        throw new AuthenticationError({
          code: 'auth/user_not_authenticated',
          message: 'User not authenticated',
          severity: 'error',
          retryable: false,
        });
      }

      const { deviceId } = req.params;

      if (!deviceId) {
        throw new ValidationError({
          code: 'auth/device_id_required',
          message: 'Device ID required',
          severity: 'error',
          retryable: false,
        });
      }

      const device = await options.twoFAService.getDevice(deviceId);
      if (!device || device.userId !== user.id) {
        throw new ValidationError({
          code: 'auth/device_not_found_or_denied',
          message: 'Device not found or access denied',
          severity: 'error',
          retryable: false,
          context: { deviceId },
        });
      }

      await options.twoFAService.deleteDevice(deviceId);

      res.json({ success: true });
    } catch (error) {
      res.status(400).json({ error: 'Failed to delete 2FA device' });
    }
  };
}

/**
 * Error handling middleware
 * Global error handling for Express apps
 */

import { Request, Response, NextFunction } from 'express';
import { getLogger } from '@kitiumai/logger';
import {
  getStatusCode,
  toAuthError,
  NotFoundError,
} from '../errors';
import { logError, problemDetailsFrom } from '@kitiumai/error';

const logger = getLogger();

/**
 * Global error handler middleware
 */
export function errorHandler(
  error: unknown,
  req: Request,
  res: Response,
  _next: NextFunction
): void {
  const kitiumError = toAuthError(error);
  const statusCode = getStatusCode(kitiumError);

  // Log error using @kitiumai/error logging
  logError(kitiumError);

  // Use Problem Details format (RFC 7807)
  const problem = problemDetailsFrom(kitiumError);

  // Enrich with request context
  const enrichedProblem = {
    ...problem,
    instance: req.path,
    extensions: {
      ...problem.extensions,
      path: req.path,
      method: req.method,
      timestamp: new Date().toISOString(),
    },
  };

  logger.error('Request error', {
    statusCode,
    path: req.path,
    method: req.method,
    error: kitiumError.code,
    message: kitiumError.message,
  });

  res.status(statusCode).json(enrichedProblem);
}

/**
 * Async handler wrapper for route handlers
 */
export function asyncHandler(
  fn: (req: Request, res: Response, next: NextFunction) => Promise<unknown>
) {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

/**
 * Setup error handling for Express app
 */
export function setupErrorHandling(app: any): void {
  // 404 handler
  app.use((req: Request, res: Response) => {
    const notFoundError = new NotFoundError({
      code: 'auth/route_not_found',
      message: 'Route not found',
      severity: 'error',
      retryable: false,
      context: { path: req.path, method: req.method },
    });
    const problem = problemDetailsFrom(notFoundError);
    res.status(404).json({
      ...problem,
      instance: req.path,
    });
  });

  // Global error handler (must be last)
  app.use(errorHandler);

  logger.info('Error handling configured');
}

/**
 * Express.js integration
 */

import { Request, Response, NextFunction } from 'express';
import { getLogger } from '@kitiumai/logger';

const logger = getLogger();

/**
 * Express auth middleware
 */
export function authMiddleware(options?: Record<string, unknown>) {
  return (req: Request, res: Response, next: NextFunction) => {
    logger.debug('Express auth middleware', { options: options || {} });
    // Store auth context in request for downstream middleware
    (req as any).auth = { options };
    next();
  };
}

/**
 * Extract JWT token from request
 */
export function extractToken(req: Request): string | null {
  const authHeader = req.get('Authorization');
  if (!authHeader?.startsWith('Bearer ')) {
    return null;
  }
  return authHeader.slice(7);
}

/**
 * Next.js integration
 */

import { getLogger } from '@kitiumai/logger';

const logger = getLogger();

/**
 * withAuth HOC for Next.js pages
 */
export function withAuth(options?: Record<string, unknown>) {
  return function withAuthHOC(Component: any) {
    return function WithAuthComponent(props: any) {
      logger.debug('withAuth HOC', { options: options || {} });
      // Merge options into props for component access
      return Component({ ...props, authOptions: options });
    };
  };
}

/**
 * Next.js API route auth middleware
 */
export async function apiAuth(
  req: any,
  res: any,
  handler: (req: any, res: any) => Promise<void>
): Promise<void> {
  logger.debug('Next.js API auth');
  await handler(req, res);
}

export interface EmailAuthRoutesConfig {}
export async function createRegisterRoute() {}
export async function createLoginRoute() {}
export async function createForgotPasswordRoute() {}
export async function createResetPasswordRoute() {}
export async function createEmailAuthRoutes() {}

export async function createOAuthRoutes() {
  return [];
}

/**
 * Rate limit middleware
 * Express middleware for rate limiting
 */

import { Request, Response, NextFunction } from 'express';
import { getLogger } from '@kitiumai/logger';
import { RateLimiter, generateRateLimitKey, generateRateLimitHeaders } from './rate-limiter';
import { RateLimitError } from '../errors';

const logger = getLogger();

/**
 * Create rate limit middleware
 */
export function createRateLimitMiddleware(maxRequests: number = 100, windowMs: number = 60000) {
  const limiter = new RateLimiter(maxRequests, windowMs);

  return (req: Request, res: Response, next: NextFunction) => {
    const key = generateRateLimitKey('ip', req.ip || 'unknown');
    const allowed = limiter.isAllowed(key);

    const headers = generateRateLimitHeaders(limiter, key, maxRequests);
    Object.entries(headers).forEach(([name, value]) => {
      res.setHeader(name, value);
    });

    if (!allowed) {
      logger.warn('Rate limit exceeded', { key, ip: req.ip });
      throw new RateLimitError({
        code: 'auth/rate_limit_exceeded',
        message: 'Too many requests',
      });
    }

    next();
  };
}

/**
 * Create public rate limit middleware (more permissive)
 */
export function createPublicRateLimitMiddleware(
  maxRequests: number = 1000,
  windowMs: number = 3600000 // 1 hour
) {
  return createRateLimitMiddleware(maxRequests, windowMs);
}

/**
 * Create per-principal rate limit middleware
 */
export function createPerPrincipalRateLimitMiddleware(
  maxRequests: number = 10000,
  windowMs: number = 3600000
) {
  const limiter = new RateLimiter(maxRequests, windowMs);

  return (req: Request, res: Response, next: NextFunction) => {
    const userId = (req as any).user?.id;
    const key = generateRateLimitKey('user', userId || 'anonymous');
    const allowed = limiter.isAllowed(key);

    const headers = generateRateLimitHeaders(limiter, key, maxRequests);
    Object.entries(headers).forEach(([name, value]) => {
      res.setHeader(name, value);
    });

    if (!allowed) {
      logger.warn('User rate limit exceeded', { key, userId });
      throw new RateLimitError({
        code: 'auth/user_rate_limit_exceeded',
        message: 'Rate limit exceeded for this user',
      });
    }

    next();
  };
}

/**
 * Create endpoint-specific rate limit middleware
 */
export function createEndpointRateLimitMiddleware(
  endpoint: string,
  maxRequests: number = 50,
  windowMs: number = 60000
) {
  const limiter = new RateLimiter(maxRequests, windowMs);

  return (req: Request, res: Response, next: NextFunction) => {
    const userId = (req as any).user?.id || 'anonymous';
    const key = generateRateLimitKey(`endpoint:${endpoint}`, userId);
    const allowed = limiter.isAllowed(key);

    const headers = generateRateLimitHeaders(limiter, key, maxRequests);
    Object.entries(headers).forEach(([name, value]) => {
      res.setHeader(name, value);
    });

    if (!allowed) {
      logger.warn('Endpoint rate limit exceeded', { endpoint, userId });
      throw new RateLimitError(`Rate limit exceeded for ${endpoint}`);
    }

    next();
  };
}

/**
 * Rate limiting
 * Track and limit request rates
 */

import { RateLimitError } from '../errors';

/**
 * Rate limit store entry
 */
interface RateLimitEntry {
  count: number;
  resetAt: number;
}

/**
 * Rate limiter
 */
export class RateLimiter {
  private store = new Map<string, RateLimitEntry>();

  constructor(
    private maxRequests: number = 100,
    private windowMs: number = 60000 // 1 minute
  ) {}

  /**
   * Check if request is allowed
   */
  isAllowed(key: string): boolean {
    const now = Date.now();
    const entry = this.store.get(key);

    if (!entry || now > entry.resetAt) {
      // Reset or create new entry
      this.store.set(key, {
        count: 1,
        resetAt: now + this.windowMs,
      });
      return true;
    }

    if (entry.count < this.maxRequests) {
      entry.count++;
      return true;
    }

    return false;
  }

  /**
   * Get current count for key
   */
  getCount(key: string): number {
    const entry = this.store.get(key);
    if (!entry || Date.now() > entry.resetAt) {
      return 0;
    }
    return entry.count;
  }

  /**
   * Get reset time for key
   */
  getResetTime(key: string): Date | null {
    const entry = this.store.get(key);
    if (!entry) {
      return null;
    }
    return new Date(entry.resetAt);
  }

  /**
   * Reset key
   */
  reset(key: string): void {
    this.store.delete(key);
  }

  /**
   * Clear all entries
   */
  clear(): void {
    this.store.clear();
  }
}

/**
 * Generate rate limit key
 */
export function generateRateLimitKey(type: string, identifier: string): string {
  return `${type}:${identifier}`;
}

/**
 * Generate rate limit headers
 */
export function generateRateLimitHeaders(
  limiter: RateLimiter,
  key: string,
  maxRequests: number
): Record<string, string> {
  const count = limiter.getCount(key);
  const resetTime = limiter.getResetTime(key);

  return {
    'RateLimit-Limit': String(maxRequests),
    'RateLimit-Remaining': String(Math.max(0, maxRequests - count)),
    'RateLimit-Reset': resetTime?.toISOString() || new Date().toISOString(),
  };
}

import { Request, Response, NextFunction } from 'express';
import { getLogger } from '@kitiumai/logger';
import { RBACService } from '../rbac/service';
import { AuthorizationError } from '../errors';

/**
 * RBAC Middleware for Express.js
 * Enforces role-based access control on routes
 */

export interface RBACMiddlewareOptions {
  rbacService: RBACService;
  orgIdExtractor?: (req: Request) => string | undefined;
}

/**
 * Require specific role for route access
 */
export function requireRole(roleNames: string[], options: RBACMiddlewareOptions) {
  const logger = getLogger();
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      if (!user || !user.id) {
        logger.warn('Role check attempted but user not authenticated', { roles: roleNames });
        throw new AuthorizationError({
          code: 'auth/user_not_authenticated',
          message: 'User not authenticated',
          severity: 'warning',
          retryable: false,
        });
      }

      const orgId = options.orgIdExtractor?.(req) || user.orgId;
      if (!orgId) {
        throw new AuthorizationError({
          code: 'auth/org_not_found',
          message: 'Organization not found in request context',
          severity: 'warning',
          retryable: false,
        });
      }

      const userRoles = await options.rbacService.getUserRoles(user.id, orgId);
      const hasRequiredRole = userRoles.some((role) => roleNames.includes(role.name));

      if (!hasRequiredRole) {
        throw new AuthorizationError({
          code: 'auth/insufficient_roles',
          message: `Required roles: ${roleNames.join(', ')}`,
          severity: 'warning',
          retryable: false,
          context: { requiredRoles: roleNames },
        });
      }

      next();
    } catch (error) {
      res.status(403).json({ error: 'Forbidden' });
    }
  };
}

/**
 * Require specific permission for route access
 */
export function requirePermission(
  resource: string,
  action: string,
  options: RBACMiddlewareOptions
) {
  const logger = getLogger();
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      if (!user || !user.id) {
        logger.warn('Permission check attempted but user not authenticated', { resource, action });
        throw new AuthorizationError({
          code: 'auth/user_not_authenticated',
          message: 'User not authenticated',
          severity: 'warning',
          retryable: false,
        });
      }

      logger.debug('Checking permission', { userId: user.id, resource, action });

      const orgId = options.orgIdExtractor?.(req) || user.orgId;

      const hasPermission = await options.rbacService.hasPermission(user.id, {
        resource,
        action,
        orgId,
      });

      if (!hasPermission) {
        throw new AuthorizationError({
          code: 'auth/insufficient_permissions',
          message: `Required permission: ${resource}:${action}`,
          severity: 'warning',
          retryable: false,
          context: { resource, action },
        });
      }

      next();
    } catch (error) {
      res.status(403).json({ error: 'Forbidden' });
    }
  };
}

/**
 * Require any of the specified permissions
 */
export function requireAnyPermission(
  checks: Array<{ resource: string; action: string }>,
  options: RBACMiddlewareOptions
) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      if (!user || !user.id) {
        throw new AuthorizationError({
          code: 'auth/user_not_authenticated',
          message: 'User not authenticated',
          severity: 'warning',
          retryable: false,
        });
      }

      const orgId = options.orgIdExtractor?.(req) || user.orgId;

      const hasPermission = await options.rbacService.hasAnyPermission(
        user.id,
        checks.map((c) => ({ ...c, orgId }))
      );

      if (!hasPermission) {
        throw new AuthorizationError({
          code: 'auth/required_permissions_not_found',
          message: 'Required permissions not found',
          severity: 'warning',
          retryable: false,
        });
      }

      next();
    } catch (error) {
      res.status(403).json({ error: 'Forbidden' });
    }
  };
}

/**
 * Require all of the specified permissions
 */
export function requireAllPermissions(
  checks: Array<{ resource: string; action: string }>,
  options: RBACMiddlewareOptions
) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      if (!user || !user.id) {
        throw new AuthorizationError({
          code: 'auth/user_not_authenticated',
          message: 'User not authenticated',
          severity: 'warning',
          retryable: false,
        });
      }

      const orgId = options.orgIdExtractor?.(req) || user.orgId;

      const hasPermission = await options.rbacService.hasAllPermissions(
        user.id,
        checks.map((c) => ({ ...c, orgId }))
      );

      if (!hasPermission) {
        throw new AuthorizationError({
          code: 'auth/not_all_permissions_found',
          message: 'Not all required permissions found',
          severity: 'warning',
          retryable: false,
        });
      }

      next();
    } catch (error) {
      res.status(403).json({ error: 'Forbidden' });
    }
  };
}

/**
 * Attach user roles and permissions to request
 */
export function enrichUserContext(options: RBACMiddlewareOptions) {
  const logger = getLogger();
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = (req as any).user;
      if (!user || !user.id) {
        return next();
      }

      const orgId = options.orgIdExtractor?.(req) || user.orgId;
      if (!orgId) {
        return next();
      }

      const roles = await options.rbacService.getUserRoles(user.id, orgId);
      const permissions = await options.rbacService.getUserPermissions(user.id, orgId);

      const enrichedUser = {
        ...user,
        roles,
        permissions,
      };
      (req as any).user = enrichedUser;

      next();
    } catch (error) {
      res.status(403).json({ error: 'Forbidden' });
    }
  };
}

export function useAuth() {
  return { user: null, isLoading: false };
}

/**
 * Access Reviews and Certification
 * Periodic access certification and review workflows
 */

import { nanoid } from 'nanoid';
import { getLogger } from '@kitiumai/logger';
import { StorageAdapter } from '../types';
import { ValidationError, AuthorizationError } from '../errors';

const logger = getLogger();

/**
 * Access review status
 */
export type AccessReviewStatus = 'pending' | 'approved' | 'rejected' | 'expired';

/**
 * Access review type
 */
export type AccessReviewType = 'user' | 'role' | 'api_key' | 'organization_member';

/**
 * Access review
 */
export interface AccessReview {
  id: string;
  orgId: string;
  type: AccessReviewType;
  resourceId: string; // userId, roleId, apiKeyId, etc.
  reviewerId: string;
  status: AccessReviewStatus;
  comments?: string;
  createdAt: Date;
  expiresAt: Date;
  reviewedAt?: Date;
  metadata?: Record<string, unknown>;
}

/**
 * Access review campaign
 */
export interface AccessReviewCampaign {
  id: string;
  orgId: string;
  name: string;
  description?: string;
  type: AccessReviewType;
  schedule?: {
    frequency: 'monthly' | 'quarterly' | 'yearly';
    dayOfMonth?: number;
  };
  autoApprove?: boolean;
  autoApproveAfterDays?: number;
  reviewers: string[]; // User IDs who can review
  status: 'draft' | 'active' | 'completed' | 'cancelled';
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  metadata?: Record<string, unknown>;
}

/**
 * Access Review Service
 */
export class AccessReviewService {
  private storage: StorageAdapter;
  private reviews: Map<string, AccessReview> = new Map();
  private campaigns: Map<string, AccessReviewCampaign> = new Map();

  constructor(storage: StorageAdapter) {
    this.storage = storage;
    logger.debug('AccessReviewService initialized', { storageType: storage.constructor.name });
  }

  /**
   * Create an access review campaign
   */
  async createCampaign(
    orgId: string,
    name: string,
    type: AccessReviewType,
    reviewers: string[],
    options?: {
      description?: string;
      schedule?: AccessReviewCampaign['schedule'];
      autoApprove?: boolean;
      autoApproveAfterDays?: number;
    }
  ): Promise<AccessReviewCampaign> {
    const campaignId = `campaign_${nanoid()}`;
    const now = new Date();

    const campaign: AccessReviewCampaign = {
      id: campaignId,
      orgId,
      name,
      description: options?.description,
      type,
      schedule: options?.schedule,
      autoApprove: options?.autoApprove || false,
      autoApproveAfterDays: options?.autoApproveAfterDays,
      reviewers,
      status: 'draft',
      createdAt: now,
      metadata: {},
    };

    this.campaigns.set(campaignId, campaign);
    logger.info('Access review campaign created', { campaignId, orgId, type });

    return campaign;
  }

  /**
   * Start an access review campaign
   */
  async startCampaign(campaignId: string): Promise<AccessReview[]> {
    const campaign = this.campaigns.get(campaignId);
    if (!campaign) {
      throw new ValidationError({
        code: 'auth/campaign_not_found',
        message: `Campaign not found: ${campaignId}`,
        context: { campaignId },
      });
    }

    if (campaign.status !== 'draft') {
      throw new ValidationError({
        code: 'auth/campaign_not_draft',
        message: 'Campaign is not in draft status',
      });
    }

    campaign.status = 'active';
    campaign.startedAt = new Date();

    // Generate reviews based on campaign type
    const reviews = await this.generateReviewsForCampaign(campaign);

    logger.info('Access review campaign started', {
      campaignId,
      reviewCount: reviews.length,
    });

    return reviews;
  }

  /**
   * Generate reviews for a campaign
   */
  private async generateReviewsForCampaign(
    campaign: AccessReviewCampaign
  ): Promise<AccessReview[]> {
    const reviews: AccessReview[] = [];
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 30); // 30 days to review

    // In production, fetch resources based on campaign type
    // For now, return empty array
    const resourceIds: string[] = [];

    for (const resourceId of resourceIds) {
      for (const reviewerId of campaign.reviewers) {
        const review: AccessReview = {
          id: `review_${nanoid()}`,
          orgId: campaign.orgId,
          type: campaign.type,
          resourceId,
          reviewerId,
          status: 'pending',
          createdAt: new Date(),
          expiresAt,
        };

        this.reviews.set(review.id, review);
        reviews.push(review);
      }
    }

    return reviews;
  }

  /**
   * Review an access review
   */
  async reviewAccess(
    reviewId: string,
    reviewerId: string,
    status: 'approved' | 'rejected',
    comments?: string
  ): Promise<AccessReview> {
    const review = this.reviews.get(reviewId);
    if (!review) {
      throw new ValidationError(`Review not found: ${reviewId}`);
    }

    if (review.reviewerId !== reviewerId) {
      throw new AuthorizationError({
        code: 'auth/review_unauthorized',
        message: 'Not authorized to review this access',
      });
    }

    if (review.status !== 'pending') {
      throw new ValidationError({
        code: 'auth/review_not_pending',
        message: 'Review is not pending',
      });
    }

    if (new Date() > review.expiresAt) {
      review.status = 'expired';
      throw new ValidationError({
        code: 'auth/review_expired',
        message: 'Review has expired',
      });
    }

    review.status = status;
    review.comments = comments;
    review.reviewedAt = new Date();

    logger.info('Access review completed', { reviewId, status, reviewerId });

    return review;
  }

  /**
   * Get pending reviews for a reviewer
   */
  async getPendingReviews(reviewerId: string, orgId?: string): Promise<AccessReview[]> {
    const reviews = Array.from(this.reviews.values()).filter(
      (r) =>
        r.reviewerId === reviewerId &&
        r.status === 'pending' &&
        (!orgId || r.orgId === orgId) &&
        new Date() <= r.expiresAt
    );

    return reviews.sort((a, b) => a.expiresAt.getTime() - b.expiresAt.getTime());
  }

  /**
   * Get reviews for a resource
   */
  async getReviewsForResource(
    resourceId: string,
    type: AccessReviewType,
    orgId?: string
  ): Promise<AccessReview[]> {
    return Array.from(this.reviews.values()).filter(
      (r) => r.resourceId === resourceId && r.type === type && (!orgId || r.orgId === orgId)
    );
  }

  /**
   * Auto-approve expired reviews
   */
  async autoApproveExpiredReviews(campaignId: string): Promise<number> {
    const campaign = this.campaigns.get(campaignId);
    if (!campaign || !campaign.autoApprove) {
      return 0;
    }

    const reviews = Array.from(this.reviews.values()).filter(
      (r) =>
        r.orgId === campaign.orgId &&
        r.type === campaign.type &&
        r.status === 'pending' &&
        new Date() > r.expiresAt
    );

    let count = 0;
    for (const review of reviews) {
      review.status = 'approved';
      review.reviewedAt = new Date();
      review.comments = 'Auto-approved after expiration';
      count++;
    }

    logger.info('Auto-approved expired reviews', { campaignId, count });
    return count;
  }

  /**
   * Complete a campaign
   */
  async completeCampaign(campaignId: string): Promise<void> {
    const campaign = this.campaigns.get(campaignId);
    if (!campaign) {
      throw new ValidationError({
        code: 'auth/campaign_not_found',
        message: `Campaign not found: ${campaignId}`,
        context: { campaignId },
      });
    }

    const pendingReviews = Array.from(this.reviews.values()).filter(
      (r) => r.orgId === campaign.orgId && r.status === 'pending'
    );

    if (pendingReviews.length > 0) {
      throw new ValidationError({
        code: 'auth/campaign_has_pending_reviews',
        message: 'Campaign has pending reviews',
      });
    }

    campaign.status = 'completed';
    campaign.completedAt = new Date();

    logger.info('Access review campaign completed', { campaignId });
  }

  /**
   * Get campaign
   */
  async getCampaign(campaignId: string): Promise<AccessReviewCampaign | null> {
    return this.campaigns.get(campaignId) || null;
  }

  /**
   * List campaigns
   */
  async listCampaigns(orgId?: string): Promise<AccessReviewCampaign[]> {
    return Array.from(this.campaigns.values()).filter((c) => !orgId || c.orgId === orgId);
  }
}

/**
 * Hook Manager Implementation
 * Manages event hooks and handlers
 */

import { nanoid } from 'nanoid';
import { getLogger } from '@kitiumai/logger';
import { HookManager, HookRegistration, HookEventType, HookContext, HookHandler } from './types';

const logger = getLogger();

/**
 * Hook Manager implementation
 */
export class HookManagerImpl implements HookManager {
  private hooks: Map<string, HookRegistration> = new Map();
  private eventHooks: Map<HookEventType, Set<string>> = new Map();

  /**
   * Register a hook handler
   */
  on<T = unknown>(event: HookEventType, handler: HookHandler<T>, priority: number = 100): string {
    const hookId = `hook_${nanoid()}`;
    const registration: HookRegistration = {
      id: hookId,
      event,
      handler: handler as HookHandler,
      priority,
      enabled: true,
    };

    this.hooks.set(hookId, registration);

    if (!this.eventHooks.has(event)) {
      this.eventHooks.set(event, new Set());
    }
    this.eventHooks.get(event)!.add(hookId);

    logger.debug('Hook registered', { hookId, event, priority });
    return hookId;
  }

  /**
   * Register a one-time hook handler
   */
  once<T = unknown>(event: HookEventType, handler: HookHandler<T>, priority: number = 100): string {
    let hookId: string;
    const wrappedHandler: HookHandler<T> = async (context, data) => {
      await handler(context, data);
      this.off(hookId);
    };

    hookId = this.on(event, wrappedHandler, priority);
    return hookId;
  }

  /**
   * Unregister a hook handler
   */
  off(hookId: string): void {
    const registration = this.hooks.get(hookId);
    if (!registration) {
      logger.warn('Hook not found', { hookId });
      return;
    }

    this.hooks.delete(hookId);
    const eventHooks = this.eventHooks.get(registration.event);
    if (eventHooks) {
      eventHooks.delete(hookId);
      if (eventHooks.size === 0) {
        this.eventHooks.delete(registration.event);
      }
    }

    logger.debug('Hook unregistered', { hookId, event: registration.event });
  }

  /**
   * Emit a hook event
   */
  async emit<T = unknown>(event: HookEventType, context: HookContext, data: T): Promise<void> {
    const hookIds = this.eventHooks.get(event);
    if (!hookIds || hookIds.size === 0) {
      return;
    }

    const registrations = Array.from(hookIds)
      .map((id) => this.hooks.get(id))
      .filter((reg): reg is HookRegistration => reg !== undefined && reg.enabled !== false)
      .sort((a, b) => (a.priority || 100) - (b.priority || 100));

    logger.debug('Emitting hook event', {
      event,
      handlerCount: registrations.length,
    });

    for (const registration of registrations) {
      try {
        await registration.handler(context, data);
      } catch (error) {
        logger.error('Hook handler error', {
          hookId: registration.id,
          event,
          error: error instanceof Error ? error.message : String(error),
        });
        // Continue executing other hooks even if one fails
      }
    }
  }

  /**
   * Get all registered hooks for an event
   */
  getHooks(event: HookEventType): HookRegistration[] {
    const hookIds = this.eventHooks.get(event);
    if (!hookIds) {
      return [];
    }

    return Array.from(hookIds)
      .map((id) => this.hooks.get(id))
      .filter((reg): reg is HookRegistration => reg !== undefined)
      .sort((a, b) => (a.priority || 100) - (b.priority || 100));
  }

  /**
   * Clear all hooks for an event (or all events)
   */
  clear(event?: HookEventType): void {
    if (event) {
      const hookIds = this.eventHooks.get(event);
      if (hookIds) {
        for (const hookId of hookIds) {
          this.hooks.delete(hookId);
        }
        this.eventHooks.delete(event);
      }
    } else {
      this.hooks.clear();
      this.eventHooks.clear();
    }

    logger.debug('Hooks cleared', { event });
  }
}

/**
 * Create a new hook manager instance
 */
export function createHookManager(): HookManager {
  return new HookManagerImpl();
}

/**
 * Hooks and Events System
 * Event-driven extensibility for authentication flows
 */

import { UserRecord, SessionRecord, ApiKeyRecord, OrganizationRecord } from '../types';

/**
 * Hook event types
 */
export type HookEventType =
  | 'user.created'
  | 'user.updated'
  | 'user.deleted'
  | 'user.email.verified'
  | 'user.password.changed'
  | 'session.created'
  | 'session.updated'
  | 'session.deleted'
  | 'session.expired'
  | 'auth.login'
  | 'auth.logout'
  | 'auth.login.failed'
  | 'auth.password.reset'
  | 'auth.email.verification.sent'
  | 'api_key.created'
  | 'api_key.revoked'
  | 'api_key.used'
  | 'organization.created'
  | 'organization.updated'
  | 'organization.deleted'
  | 'organization.member.added'
  | 'organization.member.removed'
  | 'role.assigned'
  | 'role.revoked'
  | '2fa.enabled'
  | '2fa.disabled'
  | '2fa.verified'
  | 'oauth.linked'
  | 'oauth.unlinked'
  | 'sso.login'
  | 'sso.login.failed';

/**
 * Hook context with event data
 */
export interface HookContext {
  event: HookEventType;
  timestamp: Date;
  userId?: string;
  orgId?: string;
  ipAddress?: string;
  userAgent?: string;
  metadata?: Record<string, unknown>;
}

/**
 * User-related hook data
 */
export interface UserHookData {
  user: UserRecord;
  previousUser?: UserRecord;
}

/**
 * Session-related hook data
 */
export interface SessionHookData {
  session: SessionRecord;
  previousSession?: SessionRecord;
}

/**
 * API key-related hook data
 */
export interface ApiKeyHookData {
  apiKey: ApiKeyRecord;
  previousApiKey?: ApiKeyRecord;
}

/**
 * Organization-related hook data
 */
export interface OrganizationHookData {
  organization: OrganizationRecord;
  previousOrganization?: OrganizationRecord;
  memberId?: string;
  roleId?: string;
}

/**
 * Authentication-related hook data
 */
export interface AuthHookData {
  userId: string;
  email?: string;
  provider?: string;
  success: boolean;
  reason?: string;
}

/**
 * Hook handler function type
 */
export type HookHandler<T = unknown> = (context: HookContext, data: T) => Promise<void> | void;

/**
 * Hook registration
 */
export interface HookRegistration {
  id: string;
  event: HookEventType;
  handler: HookHandler;
  priority?: number; // Lower numbers execute first
  enabled?: boolean;
}

/**
 * Hook manager interface
 */
export interface HookManager {
  /**
   * Register a hook handler
   */
  on<T = unknown>(event: HookEventType, handler: HookHandler<T>, priority?: number): string;

  /**
   * Register a one-time hook handler
   */
  once<T = unknown>(event: HookEventType, handler: HookHandler<T>, priority?: number): string;

  /**
   * Unregister a hook handler
   */
  off(hookId: string): void;

  /**
   * Emit a hook event
   */
  emit<T = unknown>(event: HookEventType, context: HookContext, data: T): Promise<void>;

  /**
   * Get all registered hooks for an event
   */
  getHooks(event: HookEventType): HookRegistration[];

  /**
   * Clear all hooks for an event
   */
  clear(event?: HookEventType): void;
}

/**
 * OAuth 2.0 utilities
 * PKCE, state management, and token handling
 */

import * as crypto from 'crypto';

/**
 * OAuth state for preventing CSRF attacks
 */
export interface OAuthState {
  state: string;
  nonce: string;
  redirectUri: string;
  createdAt: Date;
  expiresAt: Date;
}

/**
 * OAuth authorization request
 */
export interface OAuthAuthorizationRequest {
  clientId: string;
  redirectUri: string;
  scopes: string[];
  state: string;
  nonce?: string;
  codeChallenge?: string;
  codeChallengeMethod?: 'S256' | 'plain';
}

/**
 * OAuth token response
 */
export interface OAuthTokenResponse {
  access_token: string;
  token_type: string;
  expires_in?: number;
  refresh_token?: string;
  scope?: string;
  id_token?: string;
}

/**
 * PKCE Code Verifier and Challenge generator
 */
export class PKCEGenerator {
  /**
   * Generate a random code verifier
   */
  static generateCodeVerifier(): string {
    // Code verifier must be between 43-128 characters
    const randomBytes = crypto.randomBytes(32).toString('base64url');
    return randomBytes.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '').substring(0, 128);
  }

  /**
   * Generate code challenge from verifier using SHA256
   */
  static generateCodeChallenge(codeVerifier: string): string {
    return crypto
      .createHash('sha256')
      .update(codeVerifier)
      .digest('base64')
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '');
  }

  /**
   * Generate both verifier and challenge
   */
  static generate(): { codeVerifier: string; codeChallenge: string } {
    const codeVerifier = this.generateCodeVerifier();
    const codeChallenge = this.generateCodeChallenge(codeVerifier);
    return { codeVerifier, codeChallenge };
  }
}

/**
 * OAuth Manager for handling OAuth flows
 */
export class OAuthManager {
  /**
   * Generate OAuth state
   */
  static generateState(expiresInMinutes: number = 10): OAuthState {
    const state = crypto.randomBytes(32).toString('hex');
    const nonce = crypto.randomBytes(32).toString('hex');
    const createdAt = new Date();
    const expiresAt = new Date(createdAt.getTime() + expiresInMinutes * 60000);

    return {
      state,
      nonce,
      redirectUri: '',
      createdAt,
      expiresAt,
    };
  }

  /**
   * Verify state is valid and not expired
   */
  static verifyState(state: OAuthState, currentState: string): boolean {
    const isExpired = new Date() > state.expiresAt;
    const isMatching = crypto.timingSafeEqual(Buffer.from(state.state), Buffer.from(currentState));

    return !isExpired && isMatching;
  }

  /**
   * Generate authorization URL
   */
  static generateAuthorizationUrl(
    authorizationEndpoint: string,
    request: OAuthAuthorizationRequest
  ): string {
    const params = new URLSearchParams({
      client_id: request.clientId,
      redirect_uri: request.redirectUri,
      scope: request.scopes.join(' '),
      state: request.state,
      response_type: 'code',
    });

    if (request.nonce) {
      params.append('nonce', request.nonce);
    }

    if (request.codeChallenge && request.codeChallengeMethod) {
      params.append('code_challenge', request.codeChallenge);
      params.append('code_challenge_method', request.codeChallengeMethod);
    }

    return `${authorizationEndpoint}?${params.toString()}`;
  }
}

/**
 * Plugin Manager
 * Manages registration and lifecycle of auth plugins
 */

import { getLogger } from '@kitiumai/logger';
import { Plugin, PluginContext, PluginManager } from './types';

/**
 * KitiumPluginManager implementation
 */
export class KitiumPluginManager implements PluginManager {
  private plugins = new Map<string, Plugin>();
  private logger = getLogger();

  /**
   * Register a plugin
   */
  async register(plugin: Plugin): Promise<void> {
    if (this.plugins.has(plugin.name)) {
      this.logger.warn(`Plugin ${plugin.name} is already registered`);
      return;
    }

    try {
      const context: PluginContext = {
        appName: 'KitiumAuth',
        config: {},
        logger: this.logger,
        utils: {},
      };

      await plugin.setup(context);
      this.plugins.set(plugin.name, plugin);
      this.logger.info(`Plugin ${plugin.name} registered successfully`);
    } catch (error) {
      this.logger.error(`Failed to register plugin ${plugin.name}`, {
        error: String(error),
      });
      throw error;
    }
  }

  /**
   * Unregister a plugin
   */
  async unregister(pluginName: string): Promise<void> {
    const plugin = this.plugins.get(pluginName);

    if (!plugin) {
      this.logger.warn(`Plugin ${pluginName} not found`);
      return;
    }

    try {
      if (plugin.teardown) {
        await plugin.teardown();
      }

      this.plugins.delete(pluginName);
      this.logger.info(`Plugin ${pluginName} unregistered successfully`);
    } catch (error) {
      this.logger.error(`Failed to unregister plugin ${pluginName}`, {
        error: String(error),
      });
      throw error;
    }
  }

  /**
   * Get plugin by name
   */
  get(pluginName: string): Plugin | undefined {
    return this.plugins.get(pluginName);
  }

  /**
   * Get all plugins
   */
  getAll(): Plugin[] {
    return Array.from(this.plugins.values());
  }

  /**
   * Execute hook across all plugins
   */
  async executeHook(hookName: string, ...args: unknown[]): Promise<unknown> {
    const results: unknown[] = [];

    for (const plugin of this.plugins.values()) {
      if (plugin.hooks && typeof plugin.hooks[hookName] === 'function') {
        try {
          const result = await plugin.hooks[hookName](...args);
          results.push(result);
        } catch (error) {
          this.logger.warn(`Hook ${hookName} failed in plugin ${plugin.name}`, {
            error: String(error),
          });
        }
      }
    }

    return results;
  }
}

/**
 * Plugin system types
 */

/**
 * Plugin interface
 */
export interface Plugin {
  name: string;
  version: string;
  type: 'storage' | 'billing' | 'framework' | 'provider';
  setup: (context: PluginContext) => Promise<void>;
  teardown?: () => Promise<void>;
  hooks?: Record<string, Function>;
}

/**
 * Plugin context
 */
export interface PluginContext {
  appName: string;
  config: Record<string, unknown>;
  logger: any;
  utils: Record<string, unknown>;
}

/**
 * Plugin manager interface
 */
export interface PluginManager {
  register(plugin: Plugin): Promise<void>;
  unregister(pluginName: string): Promise<void>;
  get(pluginName: string): Plugin | undefined;
  getAll(): Plugin[];
  executeHook(hookName: string, ...args: unknown[]): Promise<unknown>;
}

/**
 * Pre-configured OAuth providers
 * Common OAuth providers with default configurations
 */

import { AuthProvider } from '../config';

export interface OAuthProviderPreset {
  id: string;
  name: string;
  authorizationUrl: string;
  tokenUrl: string;
  userInfoUrl: string;
  scopes: string[];
  defaultScopes: string[];
}

/**
 * Google OAuth 2.0 provider preset
 */
export const GOOGLE_PROVIDER: OAuthProviderPreset = {
  id: 'google',
  name: 'Google',
  authorizationUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
  tokenUrl: 'https://oauth2.googleapis.com/token',
  userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo',
  scopes: ['openid', 'profile', 'email'],
  defaultScopes: ['openid', 'profile', 'email'],
};

/**
 * GitHub OAuth provider preset
 */
export const GITHUB_PROVIDER: OAuthProviderPreset = {
  id: 'github',
  name: 'GitHub',
  authorizationUrl: 'https://github.com/login/oauth/authorize',
  tokenUrl: 'https://github.com/login/oauth/access_token',
  userInfoUrl: 'https://api.github.com/user',
  scopes: ['read:user', 'user:email'],
  defaultScopes: ['read:user', 'user:email'],
};

/**
 * Microsoft/Azure AD OAuth provider preset
 */
export const MICROSOFT_PROVIDER: OAuthProviderPreset = {
  id: 'microsoft',
  name: 'Microsoft',
  authorizationUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize',
  tokenUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0/token',
  userInfoUrl: 'https://graph.microsoft.com/v1.0/me',
  scopes: ['openid', 'profile', 'email', 'User.Read'],
  defaultScopes: ['openid', 'profile', 'email', 'User.Read'],
};

/**
 * Facebook OAuth provider preset
 */
export const FACEBOOK_PROVIDER: OAuthProviderPreset = {
  id: 'facebook',
  name: 'Facebook',
  authorizationUrl: 'https://www.facebook.com/v18.0/dialog/oauth',
  tokenUrl: 'https://graph.facebook.com/v18.0/oauth/access_token',
  userInfoUrl: 'https://graph.facebook.com/v18.0/me',
  scopes: ['email', 'public_profile'],
  defaultScopes: ['email', 'public_profile'],
};

/**
 * Apple OAuth provider preset
 */
export const APPLE_PROVIDER: OAuthProviderPreset = {
  id: 'apple',
  name: 'Apple',
  authorizationUrl: 'https://appleid.apple.com/auth/authorize',
  tokenUrl: 'https://appleid.apple.com/auth/token',
  userInfoUrl: '', // Apple doesn't provide userinfo endpoint
  scopes: ['name', 'email'],
  defaultScopes: ['name', 'email'],
};

/**
 * Twitter OAuth provider preset
 */
export const TWITTER_PROVIDER: OAuthProviderPreset = {
  id: 'twitter',
  name: 'Twitter',
  authorizationUrl: 'https://twitter.com/i/oauth2/authorize',
  tokenUrl: 'https://api.twitter.com/2/oauth2/token',
  userInfoUrl: 'https://api.twitter.com/2/users/me',
  scopes: ['tweet.read', 'users.read'],
  defaultScopes: ['tweet.read', 'users.read'],
};

/**
 * Discord OAuth provider preset
 */
export const DISCORD_PROVIDER: OAuthProviderPreset = {
  id: 'discord',
  name: 'Discord',
  authorizationUrl: 'https://discord.com/api/oauth2/authorize',
  tokenUrl: 'https://discord.com/api/oauth2/token',
  userInfoUrl: 'https://discord.com/api/users/@me',
  scopes: ['identify', 'email'],
  defaultScopes: ['identify', 'email'],
};

/**
 * LinkedIn OAuth provider preset
 */
export const LINKEDIN_PROVIDER: OAuthProviderPreset = {
  id: 'linkedin',
  name: 'LinkedIn',
  authorizationUrl: 'https://www.linkedin.com/oauth/v2/authorization',
  tokenUrl: 'https://www.linkedin.com/oauth/v2/accessToken',
  userInfoUrl: 'https://api.linkedin.com/v2/userinfo',
  scopes: ['openid', 'profile', 'email'],
  defaultScopes: ['openid', 'profile', 'email'],
};

/**
 * All available OAuth provider presets
 */
export const OAUTH_PROVIDER_PRESETS: Record<string, OAuthProviderPreset> = {
  google: GOOGLE_PROVIDER,
  github: GITHUB_PROVIDER,
  microsoft: MICROSOFT_PROVIDER,
  facebook: FACEBOOK_PROVIDER,
  apple: APPLE_PROVIDER,
  twitter: TWITTER_PROVIDER,
  discord: DISCORD_PROVIDER,
  linkedin: LINKEDIN_PROVIDER,
};

/**
 * Create an AuthProvider from an OAuth preset
 */
export function createOAuthProviderFromPreset(
  presetId: string,
  clientId: string,
  clientSecret: string,
  redirectUri: string,
  options?: {
    scopes?: string[];
    customScopes?: string[];
  }
): AuthProvider {
  const preset = OAUTH_PROVIDER_PRESETS[presetId.toLowerCase()];
  if (!preset) {
    throw new Error(`Unknown OAuth provider preset: ${presetId}`);
  }

  const scopes = options?.customScopes || options?.scopes || preset.defaultScopes;

  return {
    id: preset.id,
    name: preset.name,
    type: 'oauth',
    enabled: true,
    config: {
      clientId,
      clientSecret,
      redirectUri,
      authorizationUrl: preset.authorizationUrl,
      tokenUrl: preset.tokenUrl,
      userInfoUrl: preset.userInfoUrl,
      scopes,
    },
  };
}

/**
 * Get available OAuth provider presets
 */
export function getAvailableOAuthProviders(): string[] {
  return Object.keys(OAUTH_PROVIDER_PRESETS);
}

/**
 * Check if a provider preset exists
 */
export function hasOAuthProviderPreset(providerId: string): boolean {
  return providerId.toLowerCase() in OAUTH_PROVIDER_PRESETS;
}

import { nanoid } from 'nanoid';
import { getLogger } from '@kitiumai/logger';
import { Permission, Role, RoleRecord, PermissionCheck, RBACConfig, CustomRole } from '../types';
import { AuthorizationError, ValidationError } from '../errors';
import { StorageAdapter } from '../types';

/**
 * RBAC (Role-Based Access Control) Service
 * Manages roles, permissions, and role assignments
 */
export class RBACService {
  private storage: StorageAdapter;
  private config: RBACConfig;
  private logger = getLogger();

  constructor(storage: StorageAdapter, config: RBACConfig = { enabled: false }) {
    this.storage = storage;
    this.config = config;
    this.logger.debug('RBACService initialized', { enabled: config.enabled });
  }

  /**
   * Create a new role with permissions
   */
  async createRole(
    orgId: string,
    name: string,
    permissions: Permission[],
    description?: string
  ): Promise<Role> {
    if (!this.config.enabled) {
      this.logger.warn('Role creation attempted when RBAC disabled', { orgId });
      throw new ValidationError({
        code: 'auth/rbac_not_enabled',
        message: 'RBAC is not enabled',
      });
    }

    if (!name || name.trim().length === 0) {
      this.logger.warn('Role creation attempted with invalid name', { orgId });
      throw new ValidationError({
        code: 'auth/role_name_required',
        message: 'Role name is required',
      });
    }

    this.logger.debug('Creating new role', {
      orgId,
      roleName: name,
      permissionCount: permissions.length,
    });

    const roleId = `role_${nanoid()}`;
    const role: RoleRecord = {
      id: roleId,
      orgId,
      name,
      description,
      permissions,
      isSystem: false,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    if (!this.storage.createRole) {
      throw new ValidationError({
        code: 'auth/storage_adapter_not_supported',
        message: 'Role creation is not supported by storage adapter',
      });
    }

    return this.storage.createRole(role);
  }

  /**
   * Get a role by ID
   */
  async getRole(roleId: string): Promise<Role | null> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/rbac_not_enabled',
        message: 'RBAC is not enabled',
      });
    }

    if (!this.storage.getRole) {
      return null;
    }

    return this.storage.getRole(roleId);
  }

  /**
   * List all roles in an organization
   */
  async listRoles(orgId: string): Promise<Role[]> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/rbac_not_enabled',
        message: 'RBAC is not enabled',
      });
    }

    if (!this.storage.listRoles) {
      return [];
    }

    return this.storage.listRoles(orgId);
  }

  /**
   * Update a role
   */
  async updateRole(roleId: string, updates: Partial<Role>): Promise<Role> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/rbac_not_enabled',
        message: 'RBAC is not enabled',
      });
    }

    const role = await this.getRole(roleId);
    if (!role) {
      throw new ValidationError({
        code: 'auth/role_not_found',
        message: `Role not found: ${roleId}`,
        context: { roleId },
      });
    }

    if (role.isSystem) {
      throw new AuthorizationError({
        code: 'auth/system_role_immutable',
        message: 'System roles cannot be modified',
      });
    }

    if (!this.storage.updateRole) {
      throw new ValidationError({
        code: 'auth/role_update_not_supported',
        message: 'Role update is not supported by storage adapter',
      });
    }

    return this.storage.updateRole(roleId, {
      ...updates,
      updatedAt: new Date(),
    });
  }

  /**
   * Delete a role
   */
  async deleteRole(roleId: string): Promise<void> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/rbac_not_enabled',
        message: 'RBAC is not enabled',
      });
    }

    const role = await this.getRole(roleId);
    if (!role) {
      throw new ValidationError({
        code: 'auth/role_not_found',
        message: `Role not found: ${roleId}`,
        context: { roleId },
      });
    }

    if (role.isSystem) {
      throw new AuthorizationError({
        code: 'auth/system_role_immutable',
        message: 'System roles cannot be deleted',
      });
    }

    if (!this.storage.deleteRole) {
      throw new ValidationError({
        code: 'auth/role_deletion_not_supported',
        message: 'Role deletion is not supported by storage adapter',
      });
    }

    return this.storage.deleteRole(roleId);
  }

  /**
   * Assign a role to a user
   */
  async assignRoleToUser(userId: string, roleId: string, orgId: string): Promise<void> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/rbac_not_enabled',
        message: 'RBAC is not enabled',
      });
    }

    const role = await this.getRole(roleId);
    if (!role) {
      throw new ValidationError({
        code: 'auth/role_not_found',
        message: `Role not found: ${roleId}`,
        context: { roleId },
      });
    }

    if (role.orgId !== orgId) {
      throw new AuthorizationError({
        code: 'auth/role_org_mismatch',
        message: 'Role does not belong to organization',
      });
    }

    if (!this.storage.assignRoleToUser) {
      throw new ValidationError({
        code: 'auth/role_assignment_not_supported',
        message: 'Role assignment is not supported by storage adapter',
      });
    }

    await this.storage.assignRoleToUser(userId, roleId, orgId);
  }

  /**
   * Revoke a role from a user
   */
  async revokeRoleFromUser(userId: string, roleId: string, orgId: string): Promise<void> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/rbac_not_enabled',
        message: 'RBAC is not enabled',
      });
    }

    if (!this.storage.revokeRoleFromUser) {
      throw new ValidationError({
        code: 'auth/role_revocation_not_supported',
        message: 'Role revocation is not supported by storage adapter',
      });
    }

    await this.storage.revokeRoleFromUser(userId, roleId, orgId);
  }

  /**
   * Get all roles assigned to a user in an organization
   */
  async getUserRoles(userId: string, orgId: string): Promise<Role[]> {
    if (!this.config.enabled) {
      return [];
    }

    if (!this.storage.getUserRoles) {
      return [];
    }

    return this.storage.getUserRoles(userId, orgId);
  }

  /**
   * Check if a user has a specific permission
   */
  async hasPermission(userId: string, check: PermissionCheck): Promise<boolean> {
    if (!this.config.enabled) {
      return true; // RBAC disabled, allow all
    }

    const userRoles = await this.getUserRoles(userId, check.orgId || '');

    for (const role of userRoles) {
      for (const permission of role.permissions) {
        if (permission.resource === check.resource && permission.action === check.action) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Check if a user has any of the specified permissions
   */
  async hasAnyPermission(userId: string, checks: PermissionCheck[]): Promise<boolean> {
    if (!this.config.enabled) {
      return true;
    }

    for (const check of checks) {
      if (await this.hasPermission(userId, check)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Check if a user has all of the specified permissions
   */
  async hasAllPermissions(userId: string, checks: PermissionCheck[]): Promise<boolean> {
    if (!this.config.enabled) {
      return true;
    }

    for (const check of checks) {
      if (!(await this.hasPermission(userId, check))) {
        return false;
      }
    }

    return true;
  }

  /**
   * Get all permissions for a user
   */
  async getUserPermissions(userId: string, orgId: string): Promise<Permission[]> {
    const userRoles = await this.getUserRoles(userId, orgId);
    const permissions: Permission[] = [];
    const seen = new Set<string>();

    for (const role of userRoles) {
      for (const permission of role.permissions) {
        const key = `${permission.resource}:${permission.action}`;
        if (!seen.has(key)) {
          permissions.push(permission);
          seen.add(key);
        }
      }
    }

    return permissions;
  }

  /**
   * Create predefined system roles
   */
  async createSystemRoles(orgId: string): Promise<void> {
    if (!this.config.enabled) {
      return;
    }

    const adminRole = await this.createRole(
      orgId,
      'Admin',
      [{ id: 'perm_1', name: 'Admin Access', resource: '*', action: '*' }],
      'Full administrative access'
    );

    const memberRole = await this.createRole(
      orgId,
      'Member',
      [
        { id: 'perm_2', name: 'Read Access', resource: '*', action: 'read' },
        { id: 'perm_3', name: 'Write Access', resource: '*', action: 'write' },
      ],
      'Standard member access'
    );

    const viewerRole = await this.createRole(
      orgId,
      'Viewer',
      [{ id: 'perm_4', name: 'Read Only', resource: '*', action: 'read' }],
      'Read-only access'
    );
  }
}

export function createSAMLRoutes() {
  return [];
}
export function extractTenantIdMiddleware() {
  return (req: any, res: any, next: any) => {
    // Extract tenant ID from request headers or query params
    const tenantId = req.headers['x-tenant-id'] || req.query.tenantId;
    if (tenantId) {
      (req as any).tenantId = tenantId;
    }
    next();
  };
}

/**
 * SAML authentication service
 */

export class SAMLAuthService {
  async generateAuthRequest() {
    return '';
  }
  async parseSAMLResponse(response: string) {
    if (!response) {
      throw new Error('Empty SAML response');
    }
    return { response };
  }
  async validateSignature(response: string) {
    if (!response) {
      return false;
    }
    return true;
  }
}

export async function generateSAMLAuthRequest() {
  return '';
}
export async function parseSAMLResponse(response: string) {
  // Parse SAML response XML
  if (!response || response.length === 0) {
    throw new Error('Empty SAML response');
  }
  return { response };
}
export async function extractUserProfile(response: string) {
  // Extract user profile from SAML response
  if (!response || response.length === 0) {
    throw new Error('Empty SAML response');
  }
  return { profile: {}, response };
}
export async function generateSPMetadata() {
  return '';
}
export async function validateSignature(response: string) {
  return true;
}

/**
 * Anomaly Detection Service
 * Detects suspicious authentication patterns and potential attacks
 */

import { getLogger } from '@kitiumai/logger';
import { StorageAdapter } from '../types';

const logger = getLogger();

/**
 * Anomaly detection configuration
 */
export interface AnomalyDetectionConfig {
  enabled: boolean;
  bruteForceThreshold?: number; // Failed attempts before blocking
  bruteForceWindow?: number; // Time window in seconds
  suspiciousIpThreshold?: number; // Requests from same IP
  suspiciousIpWindow?: number; // Time window in seconds
  botDetectionEnabled?: boolean;
  riskScoringEnabled?: boolean;
}

/**
 * Risk score factors
 */
export interface RiskFactors {
  failedAttempts: number;
  suspiciousIp: boolean;
  newDevice: boolean;
  newLocation: boolean;
  unusualTime: boolean;
  velocityCheck: boolean;
}

/**
 * Risk score result
 */
export interface RiskScore {
  score: number; // 0-100
  level: 'low' | 'medium' | 'high' | 'critical';
  factors: RiskFactors;
  recommendations: string[];
}

/**
 * Authentication attempt record
 */
export interface AuthAttempt {
  id: string;
  userId?: string;
  email?: string;
  ipAddress: string;
  userAgent?: string;
  success: boolean;
  timestamp: Date;
  provider?: string;
  metadata?: Record<string, unknown>;
}

/**
 * Anomaly Detection Service
 */
export class AnomalyDetectionService {
  private storage: StorageAdapter;
  private config: AnomalyDetectionConfig;
  private attempts: Map<string, AuthAttempt[]> = new Map();

  constructor(storage: StorageAdapter, config: AnomalyDetectionConfig) {
    // Store references for future use
    this.storage = storage;
    this.storage = storage;
    this.config = {
      enabled: config.enabled,
      bruteForceThreshold: config.bruteForceThreshold || 5,
      bruteForceWindow: config.bruteForceWindow || 300, // 5 minutes
      suspiciousIpThreshold: config.suspiciousIpThreshold || 10,
      suspiciousIpWindow: config.suspiciousIpWindow || 60, // 1 minute
      botDetectionEnabled: config.botDetectionEnabled ?? true,
      riskScoringEnabled: config.riskScoringEnabled ?? true,
    };
    logger.debug('AnomalyDetectionService initialized', { enabled: this.config.enabled });
  }

  /**
   * Record an authentication attempt
   */
  async recordAttempt(attempt: Omit<AuthAttempt, 'id' | 'timestamp'>): Promise<void> {
    if (!this.config.enabled) {
      return;
    }

    const authAttempt: AuthAttempt = {
      ...attempt,
      id: `attempt_${Date.now()}_${Math.random()}`,
      timestamp: new Date(),
    };

    const key = attempt.email || attempt.userId || attempt.ipAddress;
    if (!this.attempts.has(key)) {
      this.attempts.set(key, []);
    }
    this.attempts.get(key)!.push(authAttempt);

    // Clean up old attempts
    this.cleanupOldAttempts(key);

    logger.debug('Auth attempt recorded', {
      key,
      success: attempt.success,
      ipAddress: attempt.ipAddress,
    });
  }

  /**
   * Check for brute force attacks
   */
  async checkBruteForce(email?: string, userId?: string, ipAddress?: string): Promise<boolean> {
    if (!this.config.enabled) {
      return false;
    }

    const key = email || userId || ipAddress;
    if (!key) {
      return false;
    }

    const attempts = this.attempts.get(key) || [];
    const windowStart = new Date(Date.now() - this.config.bruteForceWindow! * 1000);

    const recentFailedAttempts = attempts.filter((a) => !a.success && a.timestamp > windowStart);

    const isBruteForce = recentFailedAttempts.length >= this.config.bruteForceThreshold!;

    if (isBruteForce) {
      logger.warn('Brute force attack detected', {
        key,
        failedAttempts: recentFailedAttempts.length,
        threshold: this.config.bruteForceThreshold,
      });
    }

    return isBruteForce;
  }

  /**
   * Check for suspicious IP activity
   */
  async checkSuspiciousIp(ipAddress: string): Promise<boolean> {
    if (!this.config.enabled) {
      return false;
    }

    const attempts = this.attempts.get(ipAddress) || [];
    const windowStart = new Date(Date.now() - this.config.suspiciousIpWindow! * 1000);

    const recentAttempts = attempts.filter((a) => a.timestamp > windowStart);

    const isSuspicious = recentAttempts.length >= this.config.suspiciousIpThreshold!;

    if (isSuspicious) {
      logger.warn('Suspicious IP activity detected', {
        ipAddress,
        attempts: recentAttempts.length,
        threshold: this.config.suspiciousIpThreshold,
      });
    }

    return isSuspicious;
  }

  /**
   * Calculate risk score for an authentication attempt
   */
  async calculateRiskScore(
    email?: string,
    userId?: string,
    ipAddress?: string,
    userAgent?: string,
    metadata?: Record<string, unknown>
  ): Promise<RiskScore> {
    if (!this.config.enabled || !this.config.riskScoringEnabled) {
      return {
        score: 0,
        level: 'low',
        factors: {
          failedAttempts: 0,
          suspiciousIp: false,
          newDevice: false,
          newLocation: false,
          unusualTime: false,
          velocityCheck: false,
        },
        recommendations: [],
      };
    }

    const key = email || userId || ipAddress;
    const attempts = key ? this.attempts.get(key) || [] : [];
    const windowStart = new Date(Date.now() - 3600000); // 1 hour
    const recentAttempts = attempts.filter((a) => a.timestamp > windowStart);

    const failedAttempts = recentAttempts.filter((a) => !a.success).length;
    const suspiciousIp = ipAddress ? await this.checkSuspiciousIp(ipAddress) : false;
    const newDevice = metadata?.newDevice === true;
    const newLocation = metadata?.newLocation === true;
    const unusualTime = this.checkUnusualTime();
    const velocityCheck = recentAttempts.length > 20; // Too many requests

    const factors: RiskFactors = {
      failedAttempts,
      suspiciousIp,
      newDevice,
      newLocation,
      unusualTime,
      velocityCheck,
    };

    let score = 0;
    const recommendations: string[] = [];

    if (failedAttempts > 3) {
      score += 20;
      recommendations.push('Multiple failed login attempts detected');
    }
    if (suspiciousIp) {
      score += 30;
      recommendations.push('Suspicious IP address activity');
    }
    if (newDevice) {
      score += 15;
      recommendations.push('New device detected');
    }
    if (newLocation) {
      score += 15;
      recommendations.push('New location detected');
    }
    if (unusualTime) {
      score += 10;
      recommendations.push('Unusual login time');
    }
    if (velocityCheck) {
      score += 20;
      recommendations.push('High request velocity detected');
    }

    let level: 'low' | 'medium' | 'high' | 'critical';
    if (score >= 70) {
      level = 'critical';
    } else if (score >= 50) {
      level = 'high';
    } else if (score >= 30) {
      level = 'medium';
    } else {
      level = 'low';
    }

    return {
      score,
      level,
      factors,
      recommendations,
    };
  }

  /**
   * Check if login time is unusual
   */
  private checkUnusualTime(): boolean {
    const hour = new Date().getHours();
    // Consider 2 AM - 5 AM as unusual
    return hour >= 2 && hour <= 5;
  }

  /**
   * Clean up old attempts
   */
  private cleanupOldAttempts(key: string): void {
    const attempts = this.attempts.get(key);
    if (!attempts) {
      return;
    }

    const cutoff = new Date(Date.now() - 3600000); // 1 hour
    const filtered = attempts.filter((a) => a.timestamp > cutoff);

    if (filtered.length === 0) {
      this.attempts.delete(key);
    } else {
      this.attempts.set(key, filtered);
    }
  }

  /**
   * Get authentication attempt history
   */
  async getAttemptHistory(
    email?: string,
    userId?: string,
    ipAddress?: string,
    limit: number = 100
  ): Promise<AuthAttempt[]> {
    const key = email || userId || ipAddress;
    if (!key) {
      return [];
    }

    const attempts = this.attempts.get(key) || [];
    return attempts.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime()).slice(0, limit);
  }
}

/**
 * Conditional Access Policies
 * Location, device, time-based access control
 */

import { getLogger } from '@kitiumai/logger';
import { ValidationError } from '../errors';

const logger = getLogger();

/**
 * Conditional access policy type
 */
export type ConditionalAccessPolicyType =
  | 'location'
  | 'device'
  | 'time'
  | 'ip_range'
  | 'mfa_required'
  | 'risk_level';

/**
 * Location-based policy
 */
export interface LocationPolicy {
  type: 'location';
  allowedCountries?: string[]; // ISO 3166-1 alpha-2 codes
  blockedCountries?: string[];
  allowedRegions?: string[];
  blockedRegions?: string[];
}

/**
 * Device-based policy
 */
export interface DevicePolicy {
  type: 'device';
  requireDeviceTrust?: boolean;
  allowedDeviceIds?: string[];
  blockedDeviceIds?: string[];
  requireDeviceRegistration?: boolean;
}

/**
 * Time-based policy
 */
export interface TimePolicy {
  type: 'time';
  allowedDays?: number[]; // 0 = Sunday, 6 = Saturday
  allowedHours?: { start: number; end: number }[]; // 0-23
  timezone?: string;
}

/**
 * IP range policy
 */
export interface IpRangePolicy {
  type: 'ip_range';
  allowedIpRanges?: string[]; // CIDR notation
  blockedIpRanges?: string[];
}

/**
 * MFA requirement policy
 */
export interface MfaRequiredPolicy {
  type: 'mfa_required';
  requireMfa: boolean;
  mfaMethods?: ('totp' | 'sms' | 'webauthn')[];
}

/**
 * Risk level policy
 */
export interface RiskLevelPolicy {
  type: 'risk_level';
  maxRiskLevel: 'low' | 'medium' | 'high' | 'critical';
  requireMfaForHighRisk?: boolean;
  blockCriticalRisk?: boolean;
}

/**
 * Conditional access policy
 */
export type ConditionalAccessPolicy =
  | LocationPolicy
  | DevicePolicy
  | TimePolicy
  | IpRangePolicy
  | MfaRequiredPolicy
  | RiskLevelPolicy;

/**
 * Policy evaluation context
 */
export interface PolicyEvaluationContext {
  userId: string;
  orgId?: string;
  ipAddress?: string;
  country?: string;
  region?: string;
  deviceId?: string;
  deviceTrusted?: boolean;
  deviceRegistered?: boolean;
  timestamp?: Date;
  riskLevel?: 'low' | 'medium' | 'high' | 'critical';
  mfaMethods?: string[];
}

/**
 * Policy evaluation result
 */
export interface PolicyEvaluationResult {
  allowed: boolean;
  reason?: string;
  requiredActions?: string[];
  policies: Array<{
    policy: ConditionalAccessPolicy;
    allowed: boolean;
    reason?: string;
  }>;
}

/**
 * Conditional Access Service
 */
export class ConditionalAccessService {
  private policies: Map<string, ConditionalAccessPolicy[]> = new Map();

  /**
   * Add a policy for an organization or user
   */
  addPolicy(orgIdOrUserId: string, policy: ConditionalAccessPolicy, priority?: number): void {
    if (!this.policies.has(orgIdOrUserId)) {
      this.policies.set(orgIdOrUserId, []);
    }
    const policies = this.policies.get(orgIdOrUserId)!;
    // Insert policy with priority (higher priority first)
    if (priority !== undefined) {
      const index = policies.findIndex((p) => (p as any).priority !== undefined && (p as any).priority < priority);
      if (index === -1) {
        policies.push({ ...policy, priority } as any);
      } else {
        policies.splice(index, 0, { ...policy, priority } as any);
      }
    } else {
      policies.push(policy);
    }
    logger.debug('Conditional access policy added', { orgIdOrUserId, type: policy.type, priority });
  }

  /**
   * Remove a policy
   */
  removePolicy(orgIdOrUserId: string, policyType: ConditionalAccessPolicyType): void {
    const policies = this.policies.get(orgIdOrUserId);
    if (policies) {
      const filtered = policies.filter((p) => p.type !== policyType);
      this.policies.set(orgIdOrUserId, filtered);
      logger.debug('Conditional access policy removed', { orgIdOrUserId, policyType });
    }
  }

  /**
   * Get policies for an organization or user
   */
  getPolicies(orgIdOrUserId: string): ConditionalAccessPolicy[] {
    return this.policies.get(orgIdOrUserId) || [];
  }

  /**
   * Evaluate policies for a context
   */
  async evaluatePolicies(context: PolicyEvaluationContext): Promise<PolicyEvaluationResult> {
    const orgId = context.orgId || 'default';
    const userId = context.userId;
    const policies = [...this.getPolicies(orgId), ...this.getPolicies(userId)];

    if (policies.length === 0) {
      return {
        allowed: true,
        policies: [],
      };
    }

    const results: PolicyEvaluationResult['policies'] = [];
    let allowed = true;
    const requiredActions: string[] = [];

    for (const policy of policies) {
      const result = this.evaluatePolicy(policy, context);
      results.push({
        policy,
        allowed: result.allowed,
        reason: result.reason,
      });

      if (!result.allowed) {
        allowed = false;
      }

      if (result.requiredActions) {
        requiredActions.push(...result.requiredActions);
      }
    }

    return {
      allowed,
      reason: allowed ? undefined : 'One or more policies blocked access',
      requiredActions: requiredActions.length > 0 ? requiredActions : undefined,
      policies: results,
    };
  }

  /**
   * Evaluate a single policy
   */
  private evaluatePolicy(
    policy: ConditionalAccessPolicy,
    context: PolicyEvaluationContext
  ): { allowed: boolean; reason?: string; requiredActions?: string[] } {
    switch (policy.type) {
      case 'location':
        return this.evaluateLocationPolicy(policy, context);
      case 'device':
        return this.evaluateDevicePolicy(policy, context);
      case 'time':
        return this.evaluateTimePolicy(policy, context);
      case 'ip_range':
        return this.evaluateIpRangePolicy(policy, context);
      case 'mfa_required':
        return this.evaluateMfaRequiredPolicy(policy, context);
      case 'risk_level':
        return this.evaluateRiskLevelPolicy(policy, context);
      default:
        return { allowed: true };
    }
  }

  /**
   * Evaluate location policy
   */
  private evaluateLocationPolicy(
    policy: LocationPolicy,
    context: PolicyEvaluationContext
  ): { allowed: boolean; reason?: string } {
    if (!context.country) {
      return { allowed: true }; // No location data, allow
    }

    if (policy.blockedCountries?.includes(context.country)) {
      return {
        allowed: false,
        reason: `Country ${context.country} is blocked`,
      };
    }

    if (policy.allowedCountries && !policy.allowedCountries.includes(context.country)) {
      return {
        allowed: false,
        reason: `Country ${context.country} is not in allowed list`,
      };
    }

    return { allowed: true };
  }

  /**
   * Evaluate device policy
   */
  private evaluateDevicePolicy(
    policy: DevicePolicy,
    context: PolicyEvaluationContext
  ): { allowed: boolean; reason?: string; requiredActions?: string[] } {
    if (policy.requireDeviceTrust && !context.deviceTrusted) {
      return {
        allowed: false,
        reason: 'Device trust required',
        requiredActions: ['register_device'],
      };
    }

    if (policy.requireDeviceRegistration && !context.deviceRegistered) {
      return {
        allowed: false,
        reason: 'Device registration required',
        requiredActions: ['register_device'],
      };
    }

    if (policy.blockedDeviceIds?.includes(context.deviceId || '')) {
      return {
        allowed: false,
        reason: 'Device is blocked',
      };
    }

    if (
      policy.allowedDeviceIds &&
      context.deviceId &&
      !policy.allowedDeviceIds.includes(context.deviceId)
    ) {
      return {
        allowed: false,
        reason: 'Device is not in allowed list',
      };
    }

    return { allowed: true };
  }

  /**
   * Evaluate time policy
   */
  private evaluateTimePolicy(
    policy: TimePolicy,
    context: PolicyEvaluationContext
  ): { allowed: boolean; reason?: string } {
    const timestamp = context.timestamp || new Date();
    const day = timestamp.getDay();
    const hour = timestamp.getHours();

    if (policy.allowedDays && !policy.allowedDays.includes(day)) {
      return {
        allowed: false,
        reason: `Day ${day} is not in allowed days`,
      };
    }

    if (policy.allowedHours) {
      const isAllowed = policy.allowedHours.some(
        (range) => hour >= range.start && hour <= range.end
      );
      if (!isAllowed) {
        return {
          allowed: false,
          reason: `Hour ${hour} is not in allowed hours`,
        };
      }
    }

    return { allowed: true };
  }

  /**
   * Evaluate IP range policy
   */
  private evaluateIpRangePolicy(
    policy: IpRangePolicy,
    context: PolicyEvaluationContext
  ): { allowed: boolean; reason?: string } {
    if (!context.ipAddress) {
      return { allowed: true };
    }

    // Simple CIDR check (simplified - would need proper CIDR library in production)
    if (policy.blockedIpRanges) {
      for (const range of policy.blockedIpRanges) {
        if (this.isIpInRange(context.ipAddress, range)) {
          return {
            allowed: false,
            reason: `IP ${context.ipAddress} is in blocked range ${range}`,
          };
        }
      }
    }

    if (policy.allowedIpRanges && policy.allowedIpRanges.length > 0) {
      const isAllowed = policy.allowedIpRanges.some((range) =>
        this.isIpInRange(context.ipAddress!, range)
      );
      if (!isAllowed) {
        return {
          allowed: false,
          reason: `IP ${context.ipAddress} is not in allowed ranges`,
        };
      }
    }

    return { allowed: true };
  }

  /**
   * Evaluate MFA required policy
   */
  private evaluateMfaRequiredPolicy(
    policy: MfaRequiredPolicy,
    context: PolicyEvaluationContext
  ): { allowed: boolean; reason?: string; requiredActions?: string[] } {
    if (!policy.requireMfa) {
      return { allowed: true };
    }

    if (!context.mfaMethods || context.mfaMethods.length === 0) {
      return {
        allowed: false,
        reason: 'MFA is required but not configured',
        requiredActions: ['enable_mfa'],
      };
    }

    if (policy.mfaMethods) {
      const hasRequiredMethod = policy.mfaMethods.some((method) =>
        context.mfaMethods?.includes(method)
      );
      if (!hasRequiredMethod) {
        return {
          allowed: false,
          reason: 'Required MFA method not configured',
          requiredActions: ['enable_mfa'],
        };
      }
    }

    return { allowed: true };
  }

  /**
   * Evaluate risk level policy
   */
  private evaluateRiskLevelPolicy(
    policy: RiskLevelPolicy,
    context: PolicyEvaluationContext
  ): { allowed: boolean; reason?: string; requiredActions?: string[] } {
    if (!context.riskLevel) {
      return { allowed: true };
    }

    const riskLevels = ['low', 'medium', 'high', 'critical'];
    const currentRiskIndex = riskLevels.indexOf(context.riskLevel);
    const maxRiskIndex = riskLevels.indexOf(policy.maxRiskLevel);

    if (currentRiskIndex > maxRiskIndex) {
      if (policy.blockCriticalRisk && context.riskLevel === 'critical') {
        return {
          allowed: false,
          reason: 'Critical risk level - access blocked',
        };
      }

      if (policy.requireMfaForHighRisk) {
        return {
          allowed: false,
          reason: 'High risk level - MFA required',
          requiredActions: ['verify_mfa'],
        };
      }
    }

    return { allowed: true };
  }

  /**
   * Check if IP is in CIDR range (simplified)
   */
  private isIpInRange(ip: string, cidr: string): boolean {
    // Simplified implementation - would need proper CIDR library
    if (cidr.includes('/')) {
      const [rangeIp, prefix] = cidr.split('/');
      return ip.startsWith(
        rangeIp
          .split('.')
          .slice(0, parseInt(prefix) / 8)
          .join('.')
      );
    }
    return ip === cidr;
  }
}

/**
 * Device Trust and Management
 * Device registration, trust, and device-based authentication
 */

import { nanoid } from 'nanoid';
import { getLogger } from '@kitiumai/logger';
import { StorageAdapter } from '../types';
import { ValidationError, AuthenticationError } from '../errors';

const logger = getLogger();

/**
 * Device type
 */
export type DeviceType = 'desktop' | 'mobile' | 'tablet' | 'browser' | 'unknown';

/**
 * Device trust level
 */
export type DeviceTrustLevel = 'untrusted' | 'trusted' | 'verified';

/**
 * Device record
 */
export interface Device {
  id: string;
  userId: string;
  orgId?: string;
  name: string;
  type: DeviceType;
  fingerprint: string; // Device fingerprint hash
  userAgent?: string;
  ipAddress?: string;
  trustLevel: DeviceTrustLevel;
  trusted: boolean;
  verified: boolean;
  lastSeenAt: Date;
  createdAt: Date;
  metadata?: Record<string, unknown>;
}

/**
 * Device registration request
 */
export interface DeviceRegistrationRequest {
  userId: string;
  orgId?: string;
  name: string;
  fingerprint: string;
  userAgent?: string;
  ipAddress?: string;
  type?: DeviceType;
  metadata?: Record<string, unknown>;
}

/**
 * Device Management Service
 */
export class DeviceManagementService {
  private storage: StorageAdapter;
  private devices: Map<string, Device> = new Map();

  constructor(storage: StorageAdapter) {
    // Store reference for future use
    this.storage = storage;
    this.storage = storage;
    logger.debug('DeviceManagementService initialized');
  }

  /**
   * Register a new device
   */
  async registerDevice(request: DeviceRegistrationRequest): Promise<Device> {
    const deviceId = `device_${nanoid()}`;
    const now = new Date();

    // Check if device with same fingerprint already exists
    const existingDevice = Array.from(this.devices.values()).find(
      (d) => d.fingerprint === request.fingerprint && d.userId === request.userId
    );

    if (existingDevice) {
      // Update last seen
      existingDevice.lastSeenAt = now;
      return existingDevice;
    }

    const device: Device = {
      id: deviceId,
      userId: request.userId,
      orgId: request.orgId,
      name: request.name,
      type: request.type || 'unknown',
      fingerprint: request.fingerprint,
      userAgent: request.userAgent,
      ipAddress: request.ipAddress,
      trustLevel: 'untrusted',
      trusted: false,
      verified: false,
      lastSeenAt: now,
      createdAt: now,
      metadata: request.metadata,
    };

    this.devices.set(deviceId, device);
    logger.info('Device registered', { deviceId, userId: request.userId });

    return device;
  }

  /**
   * Trust a device
   */
  async trustDevice(deviceId: string, userId: string): Promise<Device> {
    const device = this.devices.get(deviceId);
    if (!device) {
      throw new ValidationError({
        code: 'auth/device_not_found',
        message: `Device not found: ${deviceId}`,
        context: { deviceId },
      });
    }

    if (device.userId !== userId) {
      throw new AuthenticationError({
        code: 'auth/device_trust_unauthorized',
        message: 'Not authorized to trust this device',
      });
    }

    device.trusted = true;
    device.trustLevel = 'trusted';
    device.lastSeenAt = new Date();

    logger.info('Device trusted', { deviceId, userId });
    return device;
  }

  /**
   * Verify a device (requires additional verification)
   */
  async verifyDevice(deviceId: string, userId: string): Promise<Device> {
    const device = this.devices.get(deviceId);
    if (!device) {
      throw new ValidationError({
        code: 'auth/device_not_found',
        message: `Device not found: ${deviceId}`,
        context: { deviceId },
      });
    }

    if (device.userId !== userId) {
      throw new AuthenticationError({
        code: 'auth/device_verify_unauthorized',
        message: 'Not authorized to verify this device',
      });
    }

    device.verified = true;
    device.trustLevel = 'verified';
    device.lastSeenAt = new Date();

    logger.info('Device verified', { deviceId, userId });
    return device;
  }

  /**
   * Untrust a device
   */
  async untrustDevice(deviceId: string, userId: string): Promise<Device> {
    const device = this.devices.get(deviceId);
    if (!device) {
      throw new ValidationError({
        code: 'auth/device_not_found',
        message: `Device not found: ${deviceId}`,
        context: { deviceId },
      });
    }

    if (device.userId !== userId) {
      throw new AuthenticationError({
        code: 'auth/device_untrust_unauthorized',
        message: 'Not authorized to untrust this device',
      });
    }

    device.trusted = false;
    device.verified = false;
    device.trustLevel = 'untrusted';

    logger.info('Device untrusted', { deviceId, userId });
    return device;
  }

  /**
   * Get device by ID
   */
  async getDevice(deviceId: string): Promise<Device | null> {
    return this.devices.get(deviceId) || null;
  }

  /**
   * Get device by fingerprint
   */
  async getDeviceByFingerprint(userId: string, fingerprint: string): Promise<Device | null> {
    return (
      Array.from(this.devices.values()).find(
        (d) => d.userId === userId && d.fingerprint === fingerprint
      ) || null
    );
  }

  /**
   * List devices for a user
   */
  async listDevices(userId: string, orgId?: string): Promise<Device[]> {
    return Array.from(this.devices.values())
      .filter((d) => d.userId === userId && (!orgId || d.orgId === orgId))
      .sort((a, b) => b.lastSeenAt.getTime() - a.lastSeenAt.getTime());
  }

  /**
   * Delete a device
   */
  async deleteDevice(deviceId: string, userId: string): Promise<void> {
    const device = this.devices.get(deviceId);
    if (!device) {
      throw new ValidationError({
        code: 'auth/device_not_found',
        message: `Device not found: ${deviceId}`,
        context: { deviceId },
      });
    }

    if (device.userId !== userId) {
      throw new AuthenticationError({
        code: 'auth/device_delete_unauthorized',
        message: 'Not authorized to delete this device',
      });
    }

    this.devices.delete(deviceId);
    logger.info('Device deleted', { deviceId, userId });
  }

  /**
   * Update device last seen
   */
  async updateLastSeen(deviceId: string): Promise<void> {
    const device = this.devices.get(deviceId);
    if (device) {
      device.lastSeenAt = new Date();
    }
  }

  /**
   * Check if device is trusted
   */
  async isDeviceTrusted(deviceId: string): Promise<boolean> {
    const device = this.devices.get(deviceId);
    return device?.trusted || false;
  }

  /**
   * Check if device is verified
   */
  async isDeviceVerified(deviceId: string): Promise<boolean> {
    const device = this.devices.get(deviceId);
    return device?.verified || false;
  }

  /**
   * Generate device fingerprint from user agent and other factors
   */
  static generateFingerprint(
    userAgent: string,
    screenWidth?: number,
    screenHeight?: number,
    timezone?: string
  ): string {
    // Simplified fingerprint generation
    // In production, use a more sophisticated algorithm
    const components = [
      userAgent,
      screenWidth?.toString() || '',
      screenHeight?.toString() || '',
      timezone || '',
    ].join('|');

    // In production, use crypto.createHash('sha256')
    return Buffer.from(components).toString('base64');
  }
}

export async function createApiRoutes() {
  return [];
}

export class HttpAuthService {
  private port: number;
  constructor(port: number) {
    this.port = port;
  }
  getPort(): number {
    return this.port;
  }
}
export async function startAuthService(port: number) {
  const service = new HttpAuthService(port);
  return service;
}

import { nanoid } from 'nanoid';
import * as jwt from 'jsonwebtoken';
import { getLogger } from '@kitiumai/logger';
import {
  SSOConfig,
  OIDCProvider,
  SAMLProvider,
  SSOSession,
  SSOLink,
  OIDCTokenResponse,
  OIDCUserInfo,
} from '../types';
import { ValidationError, AuthenticationError, NotFoundError } from '../errors';
import { StorageAdapter } from '../types';

/**
 * SSO (Single Sign-On) Service
 * Manages OIDC providers, SAML, and multi-provider SSO sessions
 */
export class SSOService {
  private storage: StorageAdapter;
  private config: SSOConfig;
  private jwtSecret: string;
  private logger = getLogger();

  constructor(storage: StorageAdapter, jwtSecret: string, config: SSOConfig = { enabled: false }) {
    this.storage = storage;
    this.jwtSecret = jwtSecret;
    this.config = config;
    this.logger.debug('SSOService initialized', { enabled: config.enabled });
  }

  /**
   * Register an OIDC provider
   */
  async registerOIDCProvider(
    provider: Omit<OIDCProvider, 'createdAt' | 'updatedAt'>
  ): Promise<OIDCProvider> {
    if (!this.config.enabled) {
      this.logger.warn('OIDC provider registration attempted when SSO disabled');
      throw new ValidationError({
        code: 'auth/sso_not_enabled',
        message: 'SSO is not enabled',
      });
    }

    this.logger.debug('Registering OIDC provider', {
      name: provider.name,
      orgId: (provider as any).orgId,
    });

    const providerId = `oidc_${nanoid()}`;
    const now = new Date();

    const oidcProvider: OIDCProvider = {
      ...provider,
      id: providerId,
      createdAt: now,
      updatedAt: now,
    };

    if (!this.storage.createSSOProvider) {
      throw new ValidationError({
        code: 'auth/sso_provider_creation_not_supported',
        message: 'SSO provider creation is not supported',
      });
    }

    return this.storage.createSSOProvider(oidcProvider);
  }

  /**
   * Register a SAML provider
   */
  async registerSAMLProvider(
    provider: Omit<SAMLProvider, 'createdAt' | 'updatedAt'>
  ): Promise<SAMLProvider> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/sso_not_enabled',
        message: 'SSO is not enabled',
      });
    }

    const providerId = `saml_${nanoid()}`;
    const now = new Date();

    const samlProvider: SAMLProvider = {
      ...provider,
      id: providerId,
      createdAt: now,
      updatedAt: now,
    };

    if (!this.storage.createSSOProvider) {
      throw new ValidationError({
        code: 'auth/sso_provider_creation_not_supported',
        message: 'SSO provider creation is not supported',
      });
    }

    return this.storage.createSSOProvider(samlProvider);
  }

  /**
   * Get SSO provider by ID
   */
  async getProvider(providerId: string): Promise<OIDCProvider | SAMLProvider | null> {
    if (!this.storage.getSSOProvider) {
      return null;
    }

    return this.storage.getSSOProvider(providerId);
  }

  /**
   * Update SSO provider
   */
  async updateProvider(
    providerId: string,
    updates: Partial<OIDCProvider | SAMLProvider>
  ): Promise<OIDCProvider | SAMLProvider> {
    if (!this.storage.updateSSOProvider) {
      throw new ValidationError({
        code: 'auth/sso_provider_update_not_supported',
        message: 'SSO provider update is not supported',
      });
    }

    return this.storage.updateSSOProvider(providerId, {
      ...updates,
      updatedAt: new Date(),
    });
  }

  /**
   * Delete SSO provider
   */
  async deleteProvider(providerId: string): Promise<void> {
    if (!this.storage.deleteSSOProvider) {
      throw new ValidationError({
        code: 'auth/sso_provider_deletion_not_supported',
        message: 'SSO provider deletion is not supported',
      });
    }

    return this.storage.deleteSSOProvider(providerId);
  }

  /**
   * List all SSO providers (optionally filtered by org)
   */
  async listProviders(orgId?: string): Promise<(OIDCProvider | SAMLProvider)[]> {
    if (!this.storage.listSSOProviders) {
      return [];
    }

    return this.storage.listSSOProviders(orgId);
  }

  /**
   * Generate OIDC authorization URL
   */
  async getOIDCAuthorizationUrl(
    providerId: string,
    state: string,
    nonce: string,
    redirectUri?: string
  ): Promise<string> {
    const provider = (await this.getProvider(providerId)) as OIDCProvider | null;
    if (!provider || provider.type !== 'oidc') {
      throw new NotFoundError({
        code: 'auth/oidc_provider_not_found',
        message: `OIDC provider not found: ${providerId}`,
        context: { providerId },
      });
    }

    // Fetch OIDC metadata
    const metadata = await this.fetchOIDCMetadata(provider.metadata_url);

    const params = new URLSearchParams({
      client_id: provider.client_id,
      redirect_uri: redirectUri || provider.redirect_uris[0],
      response_type: provider.response_type || 'code',
      scope: (provider.scopes || ['openid', 'profile', 'email']).join(' '),
      state,
      nonce,
    });

    return `${metadata.authorization_endpoint}?${params.toString()}`;
  }

  /**
   * Exchange OIDC authorization code for tokens
   */
  async exchangeOIDCCode(
    providerId: string,
    code: string,
    redirectUri: string
  ): Promise<OIDCTokenResponse & { userInfo: OIDCUserInfo }> {
    const provider = (await this.getProvider(providerId)) as OIDCProvider | null;
    if (!provider || provider.type !== 'oidc') {
      throw new NotFoundError({
        code: 'auth/oidc_provider_not_found',
        message: `OIDC provider not found: ${providerId}`,
        context: { providerId },
      });
    }

    const metadata = await this.fetchOIDCMetadata(provider.metadata_url);

    // In production, make actual HTTP request to token endpoint
    // const tokenResponse = await fetch(metadata.token_endpoint, {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    //   body: new URLSearchParams({
    //     grant_type: 'authorization_code',
    //     code,
    //     redirect_uri: redirectUri,
    //     client_id: provider.client_id,
    //     client_secret: provider.client_secret
    //   })
    // })

    // Mock response for now
    const tokenResponse: OIDCTokenResponse = {
      access_token: 'mock_access_token',
      token_type: 'Bearer',
      expires_in: 3600,
    };

    // Fetch user info
    const userInfo = await this.getOIDCUserInfo(provider, tokenResponse.access_token);

    return {
      ...tokenResponse,
      userInfo,
    };
  }

  /**
   * Get OIDC user info
   */
  private async getOIDCUserInfo(
    provider: OIDCProvider,
    accessToken: string
  ): Promise<OIDCUserInfo> {
    const metadata = await this.fetchOIDCMetadata(provider.metadata_url);

    // In production, make actual HTTP request to userinfo endpoint
    // const response = await fetch(metadata.userinfo_endpoint, {
    //   headers: { Authorization: `Bearer ${accessToken}` }
    // })
    // return response.json()

    // Mock response for now
    return {
      sub: `${provider.id}_user_${nanoid()}`,
      name: 'Test User',
      email: 'test@example.com',
      email_verified: true,
      picture: 'https://example.com/photo.jpg',
    };
  }

  /**
   * Fetch and cache OIDC metadata
   */
  private async fetchOIDCMetadata(metadataUrl: string): Promise<any> {
    // In production, cache this and implement refresh logic
    // For now, return mock metadata
    return {
      authorization_endpoint: 'https://provider.example.com/authorize',
      token_endpoint: 'https://provider.example.com/token',
      userinfo_endpoint: 'https://provider.example.com/userinfo',
      jwks_uri: 'https://provider.example.com/.well-known/jwks.json',
      issuer: 'https://provider.example.com',
    };
  }

  /**
   * Link SSO provider to user
   */
  async linkSSOProvider(
    userId: string,
    providerId: string,
    providerSubject: string,
    providerEmail?: string,
    autoProvisioned: boolean = false
  ): Promise<SSOLink> {
    const provider = await this.getProvider(providerId);
    if (!provider) {
      throw new NotFoundError({
        code: 'auth/sso_provider_not_found',
        message: `SSO provider not found: ${providerId}`,
        context: { providerId },
      });
    }

    const linkId = `sso_link_${nanoid()}`;
    const now = new Date();

    const ssoLink: SSOLink = {
      id: linkId,
      userId,
      providerId,
      providerType: provider.type as any,
      providerSubject,
      providerEmail,
      autoProvisioned,
      linkedAt: now,
      lastAuthAt: now,
    };

    if (!this.storage.createSSOLink) {
      throw new ValidationError({
        code: 'auth/sso_link_creation_not_supported',
        message: 'SSO link creation is not supported',
      });
    }

    return this.storage.createSSOLink(ssoLink);
  }

  /**
   * Get SSO link by provider subject
   */
  async getSSOLinkByProviderSubject(
    providerId: string,
    providerSubject: string
  ): Promise<SSOLink | null> {
    const links = await this.getUserSSOLinks('');
    return (
      links.find((l) => l.providerId === providerId && l.providerSubject === providerSubject) ||
      null
    );
  }

  /**
   * Get all SSO links for a user
   */
  async getUserSSOLinks(userId: string): Promise<SSOLink[]> {
    if (!this.storage.getUserSSOLinks) {
      return [];
    }

    return this.storage.getUserSSOLinks(userId);
  }

  /**
   * Delete SSO link
   */
  async deleteSSOLink(linkId: string): Promise<void> {
    if (!this.storage.deleteSSOLink) {
      throw new ValidationError({
        code: 'auth/sso_link_deletion_not_supported',
        message: 'SSO link deletion is not supported',
      });
    }

    return this.storage.deleteSSOLink(linkId);
  }

  /**
   * Create SSO session
   */
  async createSSOSession(
    userId: string,
    providerId: string,
    providerSubject: string
  ): Promise<SSOSession> {
    const provider = await this.getProvider(providerId);
    if (!provider) {
      throw new NotFoundError({
        code: 'auth/sso_provider_not_found',
        message: `SSO provider not found: ${providerId}`,
        context: { providerId },
      });
    }

    const sessionId = `sso_session_${nanoid()}`;
    const now = new Date();

    const ssoSession: SSOSession = {
      id: sessionId,
      userId,
      providerId,
      providerType: provider.type as any,
      providerSubject,
      expiresAt: new Date(now.getTime() + 24 * 60 * 60 * 1000), // 24 hours
      linkedAt: now,
      lastAuthAt: now,
    };

    if (!this.storage.createSSOSession) {
      throw new ValidationError({
        code: 'auth/sso_session_creation_not_supported',
        message: 'SSO session creation is not supported',
      });
    }

    return this.storage.createSSOSession(ssoSession);
  }

  /**
   * Get SSO session
   */
  async getSSOSession(sessionId: string): Promise<SSOSession | null> {
    if (!this.storage.getSSOSession) {
      return null;
    }

    return this.storage.getSSOSession(sessionId);
  }

  /**
   * Check if multiple SSO providers are allowed
   */
  canLinkMultipleProviders(): boolean {
    return this.config.allowMultipleProviders || false;
  }

  /**
   * Check if auto-provisioning is enabled
   */
  isAutoProvisioningEnabled(): boolean {
    return this.config.autoProvision || false;
  }

  /**
   * Check if user data sync is enabled
   */
  isSyncUserDataEnabled(): boolean {
    return this.config.syncUserData || false;
  }
}

import { nanoid } from 'nanoid';
import * as speakeasy from 'speakeasy';
import * as argon2 from 'argon2';
import { getLogger } from '@kitiumai/logger';
import {
  TwoFactorConfig,
  TwoFactorDevice,
  TOTPDevice,
  SMSDevice,
  BackupCode,
  TwoFactorSession,
  EnrollTwoFactorInput,
  VerifyTwoFactorInput,
  TwoFactorStatus,
  TwoFactorChallenge,
} from '../types';
import { ValidationError, AuthenticationError } from '../errors';
import { StorageAdapter } from '../types';
import { SMSProvider, ConsoleSMSProvider } from './sms-provider';

/**
 * Two-Factor Authentication (2FA) Service
 * Manages TOTP, SMS, and backup code enrollment and verification
 */
export class TwoFactorAuthService {
  private storage: StorageAdapter;
  private config: TwoFactorConfig;
  private smsProvider: SMSProvider;
  private logger = getLogger();

  constructor(
    storage: StorageAdapter,
    config: TwoFactorConfig = { enabled: false, methods: [] },
    smsProvider?: SMSProvider
  ) {
    this.storage = storage;
    this.config = config;
    this.smsProvider = smsProvider || new ConsoleSMSProvider();
    this.logger.debug('TwoFactorAuthService initialized', { enabled: config.enabled });
  }

  /**
   * Enable 2FA for a user
   */
  async enableTwoFactor(_userId: string): Promise<void> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/2fa_not_enabled',
        message: '2FA is not enabled',
      });
    }

    // This would update user metadata
    // const user = await this.storage.getUser(userId)
    // await this.storage.updateUser(userId, {
    //   ...user,
    //   metadata: { ...user.metadata, twoFactorEnabled: true }
    // })
  }

  /**
   * Disable 2FA for a user
   */
  async disableTwoFactor(userId: string): Promise<void> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/2fa_not_enabled',
        message: '2FA is not enabled',
      });
    }

    // Remove all devices for this user
    const devices = await this.listDevices(userId);
    for (const device of devices) {
      await this.deleteDevice(device.id);
    }
  }

  /**
   * Enroll a new 2FA device (TOTP)
   */
  async enrollTOTPDevice(userId: string, name?: string): Promise<TOTPDevice & { qrCode: string }> {
    if (!this.config.enabled) {
      this.logger.warn('2FA enrollment attempted when disabled', { userId });
      throw new ValidationError({
        code: 'auth/2fa_not_enabled',
        message: '2FA is not enabled',
      });
    }

    if (!this.config.methods.includes('totp')) {
      this.logger.warn('TOTP enrollment attempted when disabled', { userId });
      throw new ValidationError({
        code: 'auth/totp_not_enabled',
        message: 'TOTP is not enabled',
      });
    }

    this.logger.debug('Enrolling TOTP device', { userId, deviceName: name });

    const secret = speakeasy.generateSecret({
      name: `${this.config.totp?.issuer || 'Kitium'} (${userId})`,
      issuer: this.config.totp?.issuer || 'Kitium',
      length: this.config.totp?.digits || 32,
    });

    const deviceId = `totp_${nanoid()}`;
    const now = new Date();

    // Generate QR code and return
    const qrCode = secret.otpauth_url || '';

    const device: TOTPDevice = {
      id: deviceId,
      userId,
      method: 'totp',
      name,
      verified: false,
      secret: secret.base32, // In production, this should be encrypted
      backupCodesUsed: [],
      createdAt: now,
      metadata: {
        tempSecret: secret.base32,
      },
    };

    if (!this.storage.createTwoFactorDevice) {
      throw new ValidationError({
        code: 'auth/2fa_device_creation_not_supported',
        message: '2FA device creation is not supported',
      });
    }

    const savedDevice = await this.storage.createTwoFactorDevice(device);

    return {
      ...(savedDevice as TOTPDevice),
      qrCode,
    };
  }

  /**
   * Verify TOTP device enrollment
   */
  async verifyTOTPEnrollment(
    userId: string,
    deviceId: string,
    code: string
  ): Promise<BackupCode[]> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/2fa_not_enabled',
        message: '2FA is not enabled',
      });
    }

    const device = await this.getDevice(deviceId);
    if (!device || device.userId !== userId || device.method !== 'totp') {
      throw new AuthenticationError({
        code: 'auth/device_not_found',
        message: 'Device not found or invalid',
      });
    }

    if (device.verified) {
      throw new ValidationError({
        code: 'auth/device_already_verified',
        message: 'Device already verified',
      });
    }

    // Verify TOTP code
    const secret = (device as TOTPDevice).secret;
    const isValidCode = speakeasy.totp.verify({
      secret,
      encoding: 'base32',
      token: code,
      window: 1,
    });

    if (!isValidCode) {
      throw new AuthenticationError({
        code: 'auth/invalid_verification_code',
        message: 'Invalid verification code',
      });
    }

    // Mark device as verified
    if (this.storage.getTwoFactorDevice) {
      await this.storage.updateTwoFactorDevice?.(deviceId, { verified: true });
    }

    // Generate and store backup codes
    const backupCodes = await this.generateBackupCodes(userId);

    return backupCodes;
  }

  /**
   * Enroll SMS 2FA device
   */
  async enrollSMSDevice(userId: string, phoneNumber: string, name?: string): Promise<SMSDevice> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/2fa_not_enabled',
        message: '2FA is not enabled',
      });
    }

    if (!this.config.methods.includes('sms')) {
      throw new ValidationError({
        code: 'auth/sms_not_enabled',
        message: 'SMS is not enabled',
      });
    }

    const deviceId = `sms_${nanoid()}`;

    const device: SMSDevice = {
      id: deviceId,
      userId,
      method: 'sms',
      name,
      phoneNumber,
      verified: false,
      createdAt: new Date(),
    };

    if (!this.storage.createTwoFactorDevice) {
      throw new ValidationError({
        code: 'auth/2fa_device_creation_not_supported',
        message: '2FA device creation is not supported',
      });
    }

    return this.storage.createTwoFactorDevice(device) as Promise<SMSDevice>;
  }

  /**
   * Send SMS verification code
   */
  async sendSMSCode(deviceId: string): Promise<void> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/2fa_not_enabled',
        message: '2FA is not enabled',
      });
    }

    const device = await this.getDevice(deviceId);
    if (!device || device.method !== 'sms') {
      throw new ValidationError({
        code: 'auth/sms_device_not_found',
        message: 'SMS device not found',
      });
    }

    const code = Math.floor(100000 + Math.random() * 900000).toString();
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes

    // Send SMS using configured provider
    await this.smsProvider.sendVerificationCode((device as SMSDevice).phoneNumber, code);

    // Store code in database for verification
    if (this.storage.updateTwoFactorDevice) {
      await this.storage.updateTwoFactorDevice(deviceId, {
        metadata: {
          verificationCode: code,
          verificationCodeExpiresAt: expiresAt,
        },
      });
    }
  }

  /**
   * Verify SMS code
   */
  async verifySMSCode(userId: string, deviceId: string, code: string): Promise<void> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/2fa_not_enabled',
        message: '2FA is not enabled',
      });
    }

    const device = await this.getDevice(deviceId);
    if (!device || device.userId !== userId || device.method !== 'sms') {
      throw new AuthenticationError({
        code: 'auth/device_not_found',
        message: 'Device not found or invalid',
      });
    }

    const storedCode = device.metadata?.verificationCode;
    const expiresAt = device.metadata?.verificationCodeExpiresAt;

    if (!storedCode || !expiresAt) {
      throw new AuthenticationError({
        code: 'auth/no_verification_code',
        message: 'No verification code sent',
      });
    }

    if (new Date() > new Date(expiresAt)) {
      throw new AuthenticationError({
        code: 'auth/verification_code_expired',
        message: 'Verification code expired',
      });
    }

    if (code !== storedCode) {
      throw new AuthenticationError({
        code: 'auth/invalid_verification_code',
        message: 'Invalid verification code',
      });
    }

    // Mark device as verified
    if (this.storage.updateTwoFactorDevice) {
      await this.storage.updateTwoFactorDevice(deviceId, {
        verified: true,
        metadata: { verificationCode: null, verificationCodeExpiresAt: null },
      });
    }
  }

  /**
   * Verify 2FA during authentication
   */
  async verifyTwoFactor(userId: string, deviceId: string, code: string): Promise<boolean> {
    if (!this.config.enabled) {
      return true;
    }

    const device = await this.getDevice(deviceId);
    if (!device || device.userId !== userId || !device.verified) {
      throw new AuthenticationError({
        code: 'auth/device_not_found_or_unverified',
        message: 'Device not found or not verified',
      });
    }

    if (device.method === 'totp') {
      const secret = (device as TOTPDevice).secret;
      const isValid = speakeasy.totp.verify({
        secret,
        encoding: 'base32',
        token: code,
        window: 1,
      });

      if (isValid) {
        // Update last used timestamp
        if (this.storage.updateTwoFactorDevice) {
          await this.storage.updateTwoFactorDevice(deviceId, {
            lastUsedAt: new Date(),
          });
        }
        return true;
      }

      // Check if it's a backup code
      if (await this.verifyBackupCode(userId, code)) {
        return true;
      }

      throw new AuthenticationError({
        code: 'auth/invalid_2fa_code',
        message: 'Invalid 2FA code',
      });
    }

    if (device.method === 'sms') {
      // Verify SMS code
      const storedCode = device.metadata?.verificationCode;
      if (code === storedCode) {
        if (this.storage.updateTwoFactorDevice) {
          await this.storage.updateTwoFactorDevice(deviceId, {
            lastUsedAt: new Date(),
          });
        }
        return true;
      }

      throw new AuthenticationError({
        code: 'auth/invalid_2fa_code',
        message: 'Invalid 2FA code',
      });
    }

    return false;
  }

  /**
   * Generate backup codes
   */
  private async generateBackupCodes(userId: string): Promise<BackupCode[]> {
    const codes: BackupCode[] = [];
    const count = this.config.backup_codes_count || 10;

    for (let i = 0; i < count; i++) {
      const code = nanoid(8).toUpperCase();
      const hash = await argon2.hash(code);

      codes.push({
        id: `backup_${nanoid()}`,
        userId,
        code: hash,
        used: false,
        createdAt: new Date(),
      });
    }

    // Store backup codes
    if (this.storage.createBackupCodes) {
      await this.storage.createBackupCodes(userId, codes);
    }

    return codes;
  }

  /**
   * Verify a backup code
   */
  private async verifyBackupCode(userId: string, code: string): Promise<boolean> {
    if (!this.storage.getBackupCodes) {
      return false;
    }

    const codes = await this.storage.getBackupCodes(userId);

    for (const backupCode of codes) {
      if (backupCode.used) continue;

      try {
        const isValid = await argon2.verify(backupCode.code, code);
        if (isValid) {
          if (this.storage.markBackupCodeUsed) {
            await this.storage.markBackupCodeUsed(backupCode.id);
          }
          return true;
        }
      } catch (err) {
        continue;
      }
    }

    return false;
  }

  /**
   * Get a 2FA device
   */
  async getDevice(deviceId: string): Promise<TwoFactorDevice | null> {
    if (!this.storage.getTwoFactorDevice) {
      return null;
    }

    return this.storage.getTwoFactorDevice(deviceId);
  }

  /**
   * List all 2FA devices for a user
   */
  async listDevices(userId: string): Promise<TwoFactorDevice[]> {
    if (!this.storage.listTwoFactorDevices) {
      return [];
    }

    return this.storage.listTwoFactorDevices(userId);
  }

  /**
   * Delete a 2FA device
   */
  async deleteDevice(deviceId: string): Promise<void> {
    if (!this.storage.deleteTwoFactorDevice) {
      throw new ValidationError({
        code: 'auth/2fa_device_deletion_not_supported',
        message: '2FA device deletion is not supported',
      });
    }

    return this.storage.deleteTwoFactorDevice(deviceId);
  }

  /**
   * Get 2FA status for a user
   */
  async getTwoFactorStatus(userId: string): Promise<TwoFactorStatus> {
    const devices = await this.listDevices(userId);
    const backupCodes = await (this.storage.getBackupCodes?.(userId) || Promise.resolve([]));

    return {
      userId,
      enabled: devices.length > 0,
      enrolledAt: devices.length > 0 ? devices[0].createdAt : undefined,
      devices,
      backupCodesCount: backupCodes.length,
      backupCodesUsedCount: backupCodes.filter((c) => c.used).length,
    };
  }

  /**
   * Create a 2FA session for authentication flow
   */
  async createTwoFactorSession(
    userId: string,
    sessionId: string,
    deviceId: string
  ): Promise<TwoFactorSession> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/2fa_not_enabled',
        message: '2FA is not enabled',
      });
    }

    const tfaSessionId = `tfa_${nanoid()}`;
    const device = await this.getDevice(deviceId);

    if (!device || device.userId !== userId) {
      throw new ValidationError({
        code: 'auth/invalid_device',
        message: 'Invalid device',
      });
    }

    const twoFactorSession: TwoFactorSession = {
      id: tfaSessionId,
      userId,
      sessionId,
      deviceId,
      method: device.method,
      attemptCount: 0,
      maxAttempts: 5,
      expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes
      createdAt: new Date(),
    };

    if (!this.storage.createTwoFactorSession) {
      throw new ValidationError({
        code: 'auth/2fa_session_creation_not_supported',
        message: '2FA session creation is not supported',
      });
    }

    return this.storage.createTwoFactorSession(twoFactorSession);
  }

  /**
   * Complete a 2FA session
   */
  async completeTwoFactorSession(sessionId: string): Promise<void> {
    if (!this.storage.completeTwoFactorSession) {
      throw new ValidationError({
        code: 'auth/2fa_session_completion_not_supported',
        message: '2FA session completion is not supported',
      });
    }

    return this.storage.completeTwoFactorSession(sessionId);
  }
}

import { getLogger } from '@kitiumai/logger';
import { isString } from '@kitiumai/utils-ts';

/**
 * SMS Provider Interface
 * Abstract interface for sending SMS messages for 2FA
 */
export interface SMSProvider {
  /**
   * Send an SMS message to a phone number
   * @param phoneNumber - The recipient's phone number (E.164 format recommended)
   * @param message - The message content
   * @returns Promise that resolves when the message is sent
   */
  sendSMS(phoneNumber: string, message: string): Promise<void>;

  /**
   * Send a verification code via SMS
   * @param phoneNumber - The recipient's phone number
   * @param code - The verification code
   * @returns Promise that resolves when the code is sent
   */
  sendVerificationCode(phoneNumber: string, code: string): Promise<void>;
}

/**
 * Console SMS Provider
 * For testing and development - logs SMS to console instead of sending
 */
export class ConsoleSMSProvider implements SMSProvider {
  private logger = getLogger();

  async sendSMS(phoneNumber: string, message: string): Promise<void> {
    this.logger.info(`[SMS] To: ${phoneNumber}`);
    this.logger.info(`[SMS] Message: ${message}`);
  }

  async sendVerificationCode(phoneNumber: string, code: string): Promise<void> {
    const message = `Your verification code is: ${code}. This code will expire in 5 minutes.`;
    await this.sendSMS(phoneNumber, message);
  }
}

/**
 * Twilio SMS Provider
 * Production-ready SMS provider using Twilio API
 */
export class TwilioSMSProvider implements SMSProvider {
  private accountSid: string;
  private authToken: string;
  private fromNumber: string;

  constructor(accountSid: string, authToken: string, fromNumber: string) {
    this.accountSid = accountSid;
    this.authToken = authToken;
    this.fromNumber = fromNumber;
  }

  async sendSMS(phoneNumber: string, message: string): Promise<void> {
    if (!isString(phoneNumber) || phoneNumber.trim().length === 0) {
      throw new Error('Phone number is required');
    }

    // In a real implementation, this would use the Twilio client
    // For now, we'll use fetch to call the Twilio API directly
    const url = `https://api.twilio.com/2010-04-01/Accounts/${this.accountSid}/Messages.json`;

    const auth = Buffer.from(`${this.accountSid}:${this.authToken}`).toString('base64');

    const body = new URLSearchParams({
      To: phoneNumber,
      From: this.fromNumber,
      Body: message,
    });

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        Authorization: `Basic ${auth}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: body.toString(),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to send SMS: ${error}`);
    }
  }

  async sendVerificationCode(phoneNumber: string, code: string): Promise<void> {
    const message = `Your verification code is: ${code}. This code will expire in 5 minutes.`;
    await this.sendSMS(phoneNumber, message);
  }
}

/**
 * AWS SNS SMS Provider
 * Production-ready SMS provider using AWS SNS
 */
export class AWSSNSSMSProvider implements SMSProvider {
  private region: string;
  private accessKeyId: string;
  private secretAccessKey: string;

  constructor(region: string, accessKeyId: string, secretAccessKey: string) {
    this.region = region;
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
  }

  async sendSMS(phoneNumber: string, message: string): Promise<void> {
    // In a real implementation, this would use the AWS SDK
    // This is a placeholder for the AWS SNS publish operation
    // Log the parameters for debugging
    console.log('AWS SNS SMS would be sent:', {
      region: this.region,
      accessKeyId: this.accessKeyId ? `${this.accessKeyId.substring(0, 4)}...` : 'missing',
      phoneNumber,
      messageLength: message.length,
    });
    throw new Error(
      'AWS SNS SMS provider not fully implemented. Please install and configure AWS SDK.'
    );
  }

  async sendVerificationCode(phoneNumber: string, code: string): Promise<void> {
    const message = `Your verification code is: ${code}. This code will expire in 5 minutes.`;
    await this.sendSMS(phoneNumber, message);
  }
}

/**
 * Custom SMS Provider
 * Allows users to provide their own SMS sending implementation
 */
export class CustomSMSProvider implements SMSProvider {
  private sendFn: (phoneNumber: string, message: string) => Promise<void>;

  constructor(sendFn: (phoneNumber: string, message: string) => Promise<void>) {
    this.sendFn = sendFn;
  }

  async sendSMS(phoneNumber: string, message: string): Promise<void> {
    await this.sendFn(phoneNumber, message);
  }

  async sendVerificationCode(phoneNumber: string, code: string): Promise<void> {
    const message = `Your verification code is: ${code}. This code will expire in 5 minutes.`;
    await this.sendSMS(phoneNumber, message);
  }
}

/**
 * Utility to wrap SMS operations in a typed Result
 */
export function createSMSResult(error?: Error): Result<void, Error> {
  return error ? { success: false, error } : { success: true, data: undefined };
}

// Two-Factor Authentication (2FA) types

export type TwoFactorMethod = 'totp' | 'sms' | 'backup-code';

export interface TwoFactorConfig {
  enabled: boolean;
  required?: boolean; // Mandatory 2FA for all users
  methods: TwoFactorMethod[];
  grace_period_days?: number; // Days to enable 2FA after first login
  backup_codes_count?: number; // Number of backup codes to generate
  sms?: {
    provider: 'twilio' | 'aws-sns' | 'custom';
    apiKey?: string;
    apiSecret?: string;
    from?: string;
  };
  totp?: {
    issuer: string;
    algorithm?: 'SHA1' | 'SHA256' | 'SHA512';
    digits?: number; // 6 or 8 digit codes
    period?: number; // Time period in seconds (default 30)
  };
}

export interface TwoFactorDevice {
  id: string;
  userId: string;
  method: TwoFactorMethod;
  name?: string;
  verified: boolean;
  lastUsedAt?: Date;
  createdAt: Date;
  metadata?: Record<string, any>;
}

export interface TOTPDevice extends TwoFactorDevice {
  method: 'totp';
  secret: string; // Encrypted secret for authenticator apps
  backupCodesUsed: string[]; // Used backup code IDs
}

export interface SMSDevice extends TwoFactorDevice {
  method: 'sms';
  phoneNumber: string;
  verificationCode?: string;
  verificationCodeExpiresAt?: Date;
}

export interface BackupCode {
  id: string;
  userId: string;
  code: string; // Hashed code
  used: boolean;
  usedAt?: Date;
  createdAt: Date;
}

export interface TwoFactorSession {
  id: string;
  userId: string;
  sessionId: string;
  deviceId: string;
  method: TwoFactorMethod;
  verificationCode?: string;
  attemptCount: number;
  maxAttempts: number;
  expiresAt: Date;
  createdAt: Date;
  completedAt?: Date;
}

export interface TwoFactorChallenge {
  challengeId: string;
  userId: string;
  method: TwoFactorMethod;
  deviceId: string;
  expiresAt: Date;
  verificationCode?: string;
  attemptCount: number;
  maxAttempts: number;
}

export interface EnrollTwoFactorInput {
  userId: string;
  method: TwoFactorMethod;
  phoneNumber?: string; // For SMS
  name?: string; // Device name
}

export interface VerifyTwoFactorInput {
  userId: string;
  deviceId: string;
  code: string;
  sessionId?: string;
  rememberDevice?: boolean; // Remember device for 30 days
}

export interface TwoFactorStatus {
  userId: string;
  enabled: boolean;
  enrolledAt?: Date;
  devices: TwoFactorDevice[];
  backupCodesCount: number;
  backupCodesUsedCount: number;
}

export interface TwoFactorDevice {
  id: string;
  userId: string;
  method: TwoFactorMethod;
  name?: string;
  verified: boolean;
  lastUsedAt?: Date;
  createdAt: Date;
  metadata?: Record<string, any>;
}

// Database record types
export interface TOTPDeviceRecord extends TOTPDevice {}

export interface SMSDeviceRecord extends SMSDevice {}

export interface BackupCodeRecord extends BackupCode {}

export interface TwoFactorSessionRecord extends TwoFactorSession {}

// Core types for the authentication system

export type Scope = string;

export interface Principal {
  id: string;
  type: 'user' | 'org' | 'service';
  orgId?: string;
  plan?: string;
  entitlements: Scope[];
  metadata?: Record<string, any>;
}

export interface IssueApiKeyInput {
  principalId: string;
  scopes: Scope[];
  metadata?: Record<string, string>;
  expiresAt?: Date;
  name?: string;
  prefix?: string;
}

export interface IssueApiKeyResult {
  id: string;
  key: string;
  prefix: string;
  lastFour: string;
  expiresAt?: Date;
  createdAt: Date;
}

export interface VerifyApiKeyResult {
  valid: boolean;
  principalId?: string;
  scopes?: Scope[];
  plan?: string;
  orgId?: string;
  rateLimit?: {
    limit: number;
    periodSec: number;
  };
  keyId?: string;
  expiresAt?: Date;
}

export interface Session {
  id: string;
  userId: string;
  orgId?: string;
  plan?: string;
  entitlements: Scope[];
  expiresAt: Date;
  createdAt: Date;
  metadata?: Record<string, any>;
}

export interface Entitlement {
  scope: Scope;
  plan: string;
  description?: string;
}

export interface Plan {
  id: string;
  name: string;
  entitlements: Scope[];
  seats?: number;
  metadata?: Record<string, any>;
}

export interface Organization {
  id: string;
  name: string;
  plan: string;
  seats: number;
  members: OrganizationMember[];
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

export interface OrganizationMember {
  userId: string;
  role: 'owner' | 'admin' | 'member';
  joinedAt: Date;
}

export interface AuthEvent {
  type: string;
  principalId: string;
  orgId?: string;
  data: Record<string, any>;
  timestamp: Date;
}

export interface RateLimit {
  limit: number;
  periodSec: number;
  remaining?: number;
  resetAt?: Date;
}

export interface AuthConfig {
  appUrl: string;
  providers: AuthProvider[];
  storage: StorageConfig;
  billing?: BillingConfig;
  apiKeys: ApiKeyConfig;
  sessions: SessionConfig;
  orgs?: OrganizationConfig;
  events?: EventConfig;
}

export interface AuthProvider {
  id: string;
  type: 'oauth' | 'email' | 'saml';
  clientId?: string;
  clientSecret?: string;
  redirectUri?: string;
  scopes?: string[];
  metadata?: Record<string, any>;
}

export interface StorageConfig {
  driver: 'postgres' | 'mysql' | 'sqlite' | 'memory';
  url?: string;
  options?: Record<string, any>;
}

export interface BillingConfig {
  driver: 'stripe' | 'paddle' | 'custom';
  secretKey?: string;
  webhookSecret?: string;
  products: Record<string, BillingProduct>;
}

export interface BillingProduct {
  plan: string;
  entitlements: Scope[];
  seats?: number;
  metadata?: Record<string, any>;
}

export interface ApiKeyConfig {
  prefix: string;
  hash: {
    algo: 'argon2id' | 'bcrypt' | 'scrypt';
    timeCost?: number;
    memory?: number;
    parallelism?: number;
  };
  defaultExpiry?: number; // seconds
}

export interface SessionConfig {
  cookieName: string;
  ttlSeconds: number;
  secure?: boolean;
  httpOnly?: boolean;
  sameSite?: 'strict' | 'lax' | 'none';
}

export interface OrganizationConfig {
  enabled: boolean;
  defaultRole: 'owner' | 'admin' | 'member';
  maxSeats?: number;
}

export interface EventConfig {
  webhookSecret?: string;
  webhookUrl?: string;
  events: string[];
}

// Adapter interfaces
export interface StorageAdapter {
  connect(): Promise<void>;
  disconnect(): Promise<void>;

  // API Keys
  createApiKey(data: Omit<ApiKeyRecord, 'id' | 'createdAt'>): Promise<ApiKeyRecord>;
  getApiKey(id: string): Promise<ApiKeyRecord | null>;
  getApiKeyByHash(hash: string): Promise<ApiKeyRecord | null>;
  getApiKeysByPrefixAndLastFour(prefix: string, lastFour: string): Promise<ApiKeyRecord[]>;
  updateApiKey(id: string, data: Partial<ApiKeyRecord>): Promise<ApiKeyRecord>;
  deleteApiKey(id: string): Promise<void>;
  listApiKeys(principalId: string): Promise<ApiKeyRecord[]>;

  // Sessions
  createSession(data: Omit<SessionRecord, 'id' | 'createdAt'>): Promise<SessionRecord>;
  getSession(id: string): Promise<SessionRecord | null>;
  updateSession(id: string, data: Partial<SessionRecord>): Promise<SessionRecord>;
  deleteSession(id: string): Promise<void>;

  // Organizations
  createOrganization(
    data: Omit<OrganizationRecord, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<OrganizationRecord>;
  getOrganization(id: string): Promise<OrganizationRecord | null>;
  updateOrganization(id: string, data: Partial<OrganizationRecord>): Promise<OrganizationRecord>;
  deleteOrganization(id: string): Promise<void>;

  // Users
  createUser(data: CreateUserInput): Promise<UserRecord>;
  getUser(id: string): Promise<UserRecord | null>;
  getUserByEmail(email: string): Promise<UserRecord | null>;
  getUserByOAuth(provider: string, sub: string): Promise<UserRecord | null>;
  updateUser(id: string, data: UpdateUserInput): Promise<UserRecord>;
  deleteUser(id: string): Promise<void>;
  linkOAuthAccount(userId: string, provider: string, oauthLink: OAuthLink): Promise<UserRecord>;

  // Email Verification Tokens
  createEmailVerificationToken(
    data: Omit<EmailVerificationToken, 'id'>
  ): Promise<EmailVerificationToken>;
  getEmailVerificationTokens(email: string, type?: string): Promise<EmailVerificationToken[]>;
  getEmailVerificationTokenById(id: string): Promise<EmailVerificationToken | null>;
  markEmailVerificationTokenAsUsed(id: string): Promise<EmailVerificationToken>;
  deleteExpiredEmailVerificationTokens(): Promise<number>;
  getEmailVerificationTokenAttempts(tokenId: string): Promise<number>;
  incrementEmailVerificationTokenAttempts(tokenId: string): Promise<number>;

  // SAML Configuration (optional - for multi-tenant SAML)
  storeTenantSAMLConfig?(config: any): Promise<void>;
  getTenantSAMLConfig?(tenantId: string): Promise<any | null>;
  updateTenantSAMLConfig?(tenantId: string, updates: Partial<any>): Promise<void>;
  deleteTenantSAMLConfig?(tenantId: string): Promise<void>;

  // RBAC (optional)
  createRole?(data: Omit<any, 'id' | 'createdAt' | 'updatedAt'>): Promise<any>;
  getRole?(roleId: string): Promise<any | null>;
  updateRole?(roleId: string, data: Partial<any>): Promise<any>;
  deleteRole?(roleId: string): Promise<void>;
  listRoles?(orgId: string): Promise<any[]>;
  assignRoleToUser?(userId: string, roleId: string, orgId: string): Promise<any>;
  revokeRoleFromUser?(userId: string, roleId: string, orgId: string): Promise<void>;
  getUserRoles?(userId: string, orgId: string): Promise<any[]>;

  // 2FA (optional)
  createTwoFactorDevice?(data: any): Promise<any>;
  getTwoFactorDevice?(deviceId: string): Promise<any | null>;
  updateTwoFactorDevice?(deviceId: string, data: Partial<any>): Promise<any>;
  listTwoFactorDevices?(userId: string): Promise<any[]>;
  deleteTwoFactorDevice?(deviceId: string): Promise<void>;
  createBackupCodes?(userId: string, codes: any[]): Promise<any[]>;
  getBackupCodes?(userId: string): Promise<any[]>;
  markBackupCodeUsed?(codeId: string): Promise<void>;
  createTwoFactorSession?(data: any): Promise<any>;
  getTwoFactorSession?(sessionId: string): Promise<any | null>;
  completeTwoFactorSession?(sessionId: string): Promise<void>;

  // SSO (optional)
  createSSOProvider?(data: any): Promise<any>;
  getSSOProvider?(providerId: string): Promise<any | null>;
  updateSSOProvider?(providerId: string, data: Partial<any>): Promise<any>;
  deleteSSOProvider?(providerId: string): Promise<void>;
  listSSOProviders?(orgId?: string): Promise<any[]>;
  createSSOLink?(data: any): Promise<any>;
  getSSOLink?(linkId: string): Promise<any | null>;
  getUserSSOLinks?(userId: string): Promise<any[]>;
  deleteSSOLink?(linkId: string): Promise<void>;
  createSSOSession?(data: any): Promise<any>;
  getSSOSession?(sessionId: string): Promise<any | null>;

  // Events
  emitEvent(event: AuthEvent): Promise<void>;
}

export interface BillingAdapter {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  createCustomer(data: CustomerData): Promise<Customer>;
  getCustomer(id: string): Promise<Customer | null>;
  updateCustomer(id: string, data: Partial<CustomerData>): Promise<Customer>;
  createSubscription(data: SubscriptionData): Promise<Subscription>;
  getSubscription(id: string): Promise<Subscription | null>;
  updateSubscription(id: string, data: Partial<SubscriptionData>): Promise<Subscription>;
  cancelSubscription(id: string): Promise<Subscription>;
  processWebhook(payload: any, signature: string): Promise<WebhookEvent>;
}

export interface CacheAdapter {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  get(key: string): Promise<any>;
  set(key: string, value: any, ttl?: number): Promise<void>;
  del(key: string): Promise<void>;
  exists(key: string): Promise<boolean>;
  expire(key: string, ttl: number): Promise<void>;
}

// Database record types
export interface ApiKeyRecord {
  id: string;
  principalId: string;
  hash: string;
  prefix: string;
  lastFour: string;
  scopes: Scope[];
  metadata?: Record<string, string>;
  expiresAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

export interface SessionRecord {
  id: string;
  userId: string;
  orgId?: string;
  plan?: string;
  entitlements: Scope[];
  expiresAt: Date;
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

export interface OrganizationRecord {
  id: string;
  name: string;
  plan: string;
  seats: number;
  members: OrganizationMember[];
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

// User types
export interface User {
  id: string;
  email?: string;
  name?: string;
  picture?: string;
  plan?: string;
  entitlements: Scope[];
  oauth?: Record<string, OAuthLink>;
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

export interface OAuthLink {
  provider: string;
  sub: string;
  email?: string;
  name?: string;
  linkedAt: Date;
}

export interface UserRecord extends User {}

export interface CreateUserInput {
  email?: string;
  name?: string;
  picture?: string;
  plan?: string;
  entitlements?: Scope[];
  metadata?: Record<string, any>;
}

export interface UpdateUserInput {
  email?: string;
  name?: string;
  picture?: string;
  plan?: string;
  entitlements?: Scope[];
  metadata?: Record<string, any>;
}

// Email verification types
export interface EmailVerificationToken {
  id: string;
  email: string;
  code: string;
  codeHash: string;
  type: 'verify_email' | 'reset_password' | 'change_email' | 'login_link';
  userId?: string;
  metadata?: Record<string, any>;
  expiresAt: Date;
  createdAt: Date;
  usedAt?: Date;
}

// Billing types
export interface Customer {
  id: string;
  email: string;
  name?: string;
  metadata?: Record<string, any>;
  createdAt: Date;
}

export interface CustomerData {
  email: string;
  name?: string;
  metadata?: Record<string, any>;
}

export interface Subscription {
  id: string;
  customerId: string;
  productId: string;
  status: 'active' | 'canceled' | 'past_due' | 'unpaid';
  currentPeriodStart: Date;
  currentPeriodEnd: Date;
  metadata?: Record<string, any>;
  createdAt: Date;
}

export interface SubscriptionData {
  customerId: string;
  productId: string;
  metadata?: Record<string, any>;
}

export interface WebhookEvent {
  type: string;
  data: any;
  timestamp: Date;
}

// OAuth types
export interface OAuthCallbackResult {
  userId: string;
  session: Session;
  profile: OAuthProfile;
  tokens: OAuthTokenResponse;
}

export interface OAuthProfile {
  sub: string;
  email?: string;
  name?: string;
  picture?: string;
  emailVerified?: boolean;
  metadata?: Record<string, any>;
}

export interface OAuthTokenResponse {
  accessToken: string;
  refreshToken?: string;
  idToken?: string;
  expiresIn: number;
  tokenType: string;
  scope?: string;
}

export * from './provider';
export * from './rbac';
export * from './2fa';
export * from './sso';

/**
 * Provider types for authentication
 */

export type ProviderType = 'oauth' | 'email' | 'saml' | 'magic-link';

export interface Provider {
  id: string;
  type: ProviderType;
  enabled: boolean;
  name: string;
  metadata?: Record<string, any>;
}

export interface OAuthProvider extends Provider {
  type: 'oauth';
  clientId: string;
  clientSecret: string;
  discoveryUrl?: string;
  authorizationUrl: string;
  tokenUrl: string;
  userinfoUrl: string;
  scope?: string[];
  authorizationMethod?: 'header' | 'body';
}

export interface EmailProvider extends Provider {
  type: 'email';
  fromEmail: string;
  fromName?: string;
  replyTo?: string;
}

export interface SAMLProvider extends Provider {
  type: 'saml';
  entryPoint: string;
  issuer: string;
  cert: string;
  identifierFormat?: string;
  wantAssertionsSigned?: boolean;
}

export interface MagicLinkProvider extends Provider {
  type: 'magic-link';
  tokenExpiryMinutes?: number;
}

export type AuthProvider = OAuthProvider | EmailProvider | SAMLProvider | MagicLinkProvider;

// Enhanced RBAC (Role-Based Access Control) types

export interface Permission {
  id: string;
  name: string;
  description?: string;
  resource: string;
  action: string; // e.g., 'read', 'write', 'delete', 'admin'
  metadata?: Record<string, any>;
}

export interface Role {
  id: string;
  orgId: string;
  name: string;
  description?: string;
  permissions: Permission[];
  isSystem?: boolean; // System roles cannot be modified
  createdAt: Date;
  updatedAt: Date;
}

export interface CustomRole {
  id: string;
  orgId: string;
  userId: string;
  roleId: string;
  role: Role;
  assignedAt: Date;
}

export interface PermissionCheck {
  resource: string;
  action: string;
  orgId?: string;
}

export interface RBACConfig {
  enabled: boolean;
  defaultRoles?: string[]; // IDs of default roles to assign
  customRolesAllowed?: boolean;
  hierarchySupport?: boolean;
}

export interface RoleRecord {
  id: string;
  orgId: string;
  name: string;
  description?: string;
  permissions: Permission[];
  isSystem: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface CustomRoleRecord {
  id: string;
  orgId: string;
  userId: string;
  roleId: string;
  assignedAt: Date;
}

// Single Sign-On (SSO) types for enhanced OIDC and multi-provider support

export type SSOProviderType = 'saml' | 'oidc' | 'oauth';

export interface SSOConfig {
  enabled: boolean;
  allowMultipleProviders?: boolean; // Allow linking multiple SSO providers
  autoProvision?: boolean; // Auto-create users on first login
  defaultPlan?: string; // Plan to assign to auto-provisioned users
  syncUserData?: boolean; // Sync user profile data from provider
}

export interface OIDCProvider {
  id: string;
  type: 'oidc';
  name: string;
  metadata_url: string; // OIDC provider metadata endpoint
  client_id: string;
  client_secret: string;
  redirect_uris: string[];
  scopes?: string[]; // Default: ['openid', 'profile', 'email']
  response_type?: string; // Default: 'code'
  token_endpoint_auth_method?: string; // Default: 'client_secret_basic'
  claim_mapping?: {
    nameAttribute?: string; // Default: 'name'
    emailAttribute?: string; // Default: 'email'
    pictureAttribute?: string; // Default: 'picture'
    subAttribute?: string; // Default: 'sub'
  };
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

export interface SSOSAMLProvider {
  id: string;
  type: 'saml';
  name: string;
  idp_entity_id: string;
  idp_sso_url: string;
  idp_slo_url?: string;
  idp_certificate?: string; // Public certificate for signature verification
  sp_entity_id: string;
  sp_acs_url: string;
  sp_slo_url?: string;
  signing_cert?: string;
  signing_key?: string;
  encryption_enabled?: boolean;
  force_authn?: boolean; // Force re-authentication
  allow_unencrypted_assertion?: boolean;
  attribute_mapping?: {
    nameAttribute?: string; // Default: 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name'
    emailAttribute?: string; // Default: 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress'
    pictureAttribute?: string;
    subAttribute?: string; // Default: 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier'
  };
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

export interface SSOSession {
  id: string;
  userId: string;
  providerId: string;
  providerType: SSOProviderType;
  providerSubject: string; // Subject ID from provider
  sessionToken?: string; // Session token from provider
  expiresAt: Date;
  linkedAt: Date;
  lastAuthAt: Date;
}

export interface SSOLink {
  id: string;
  userId: string;
  providerId: string;
  providerType: SSOProviderType;
  providerSubject: string; // Remote user ID from provider
  providerEmail?: string; // Email from provider
  autoProvisioned?: boolean;
  metadata?: Record<string, any>;
  linkedAt: Date;
  lastAuthAt: Date;
}

export interface OIDCTokenResponse {
  access_token: string;
  token_type: string;
  expires_in?: number;
  refresh_token?: string;
  id_token?: string;
  scope?: string;
}

export interface OIDCUserInfo {
  sub: string;
  name?: string;
  email?: string;
  email_verified?: boolean;
  picture?: string;
  locale?: string;
  metadata?: Record<string, any>;
}

export interface SAMLAssertion {
  nameID: string;
  sessionIndex?: string;
  notBefore?: Date;
  notOnOrAfter?: Date;
  attributes?: Record<string, any>;
  metadata?: Record<string, any>;
}

// Database record types
export interface OIDCProviderRecord extends OIDCProvider {}

export interface SAMLProviderRecord extends SSOSAMLProvider {}

export interface SSOSessionRecord extends SSOSession {}

export interface SSOLinkRecord extends SSOLink {}

/**
 * WebAuthn/FIDO2 Service
 * Passwordless authentication using WebAuthn API
 */

import * as crypto from 'crypto';
import { nanoid } from 'nanoid';
import { getLogger } from '@kitiumai/logger';
import { StorageAdapter } from '../types';
import { ValidationError, AuthenticationError } from '../errors';
import {
  WebAuthnDevice,
  WebAuthnConfig,
  WebAuthnRegistrationOptions,
  WebAuthnAuthenticationOptions,
  WebAuthnCredentialCreation,
  WebAuthnCredentialAssertion,
} from './types';

const logger = getLogger();

/**
 * WebAuthn Service
 */
export class WebAuthnService {
  private storage: StorageAdapter;
  private config: WebAuthnConfig;

  getStorage(): StorageAdapter {
    return this.storage;
  }
  private challenges: Map<string, { challenge: string; expiresAt: Date; userId?: string }> =
    new Map();

  constructor(storage: StorageAdapter, config: WebAuthnConfig) {
    this.storage = storage;
    this.config = config;
    logger.debug('WebAuthnService initialized', { enabled: config.enabled });
  }

  /**
   * Generate registration options for a user
   */
  async generateRegistrationOptions(
    userId: string,
    userName: string,
    userDisplayName: string,
    excludeCredentials?: Array<{ id: string; transports?: string[] }>
  ): Promise<WebAuthnRegistrationOptions> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/webauthn_not_enabled',
        message: 'WebAuthn is not enabled',
        severity: 'error',
        retryable: false,
      });
    }

    const challenge = crypto.randomBytes(32).toString('base64url');
    const challengeId = `challenge_${nanoid()}`;
    const expiresAt = new Date(Date.now() + (this.config.timeout || 60000));

    this.challenges.set(challengeId, { challenge, expiresAt, userId });

    // Clean up expired challenges
    this.cleanupExpiredChallenges();

    const options: WebAuthnRegistrationOptions = {
      challenge,
      rp: {
        name: this.config.rpName,
        id: this.config.rpId,
      },
      user: {
        id: Buffer.from(userId).toString('base64url'),
        name: userName,
        displayName: userDisplayName,
      },
      pubKeyCredParams: [
        { type: 'public-key', alg: -7 }, // ES256
        { type: 'public-key', alg: -257 }, // RS256
      ],
      timeout: this.config.timeout,
      attestation: this.config.attestation || 'none',
      excludeCredentials: excludeCredentials?.map((cred) => ({
        id: cred.id,
        type: 'public-key',
        transports: cred.transports as any,
      })),
      authenticatorSelection: this.config.authenticatorSelection,
    };

    logger.debug('WebAuthn registration options generated', { userId, challengeId });
    return options;
  }

  /**
   * Verify and store a WebAuthn credential
   */
  async verifyAndStoreCredential(
    userId: string,
    credential: WebAuthnCredentialCreation,
    challengeId: string
  ): Promise<WebAuthnDevice> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/webauthn_not_enabled',
        message: 'WebAuthn is not enabled',
        severity: 'error',
        retryable: false,
      });
    }

    const storedChallenge = this.challenges.get(challengeId);
    if (!storedChallenge || storedChallenge.userId !== userId) {
      throw new AuthenticationError({
        code: 'auth/invalid_challenge',
        message: 'Invalid or expired challenge',
        severity: 'error',
        retryable: false,
      });
    }

    if (new Date() > storedChallenge.expiresAt) {
      this.challenges.delete(challengeId);
      throw new AuthenticationError({
        code: 'auth/challenge_expired',
        message: 'Challenge expired',
      });
    }

    // In production, verify the attestation object and signature
    // This is a simplified version
    const deviceId = `webauthn_${nanoid()}`;
    const now = new Date();

    const device: WebAuthnDevice = {
      id: deviceId,
      userId,
      name: 'WebAuthn Device',
      credentialId: credential.credentialId,
      publicKey: credential.publicKey,
      counter: 0,
      transports: credential.transports,
      createdAt: now,
      verified: true,
    };

    // Store device in storage (would need storage adapter extension)
    // await this.storage.createWebAuthnDevice(device);

    this.challenges.delete(challengeId);
    logger.info('WebAuthn credential registered', { userId, deviceId });

    return device;
  }

  /**
   * Generate authentication options for a user
   */
  async generateAuthenticationOptions(
    userId: string,
    allowCredentials?: Array<{ id: string; transports?: string[] }>
  ): Promise<WebAuthnAuthenticationOptions> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/webauthn_not_enabled',
        message: 'WebAuthn is not enabled',
        severity: 'error',
        retryable: false,
      });
    }

    const challenge = crypto.randomBytes(32).toString('base64url');
    const challengeId = `challenge_${nanoid()}`;
    const expiresAt = new Date(Date.now() + (this.config.timeout || 60000));

    this.challenges.set(challengeId, { challenge, expiresAt, userId });

    const options: WebAuthnAuthenticationOptions = {
      challenge,
      timeout: this.config.timeout,
      rpId: this.config.rpId,
      allowCredentials: allowCredentials?.map((cred) => ({
        id: cred.id,
        type: 'public-key',
        transports: cred.transports as any,
      })),
      userVerification: this.config.authenticatorSelection?.userVerification || 'preferred',
    };

    logger.debug('WebAuthn authentication options generated', { userId, challengeId });
    return options;
  }

  /**
   * Verify a WebAuthn authentication assertion
   */
  async verifyAuthentication(
    userId: string,
    assertion: WebAuthnCredentialAssertion,
    challengeId: string
  ): Promise<WebAuthnDevice> {
    if (!this.config.enabled) {
      throw new ValidationError({
        code: 'auth/webauthn_not_enabled',
        message: 'WebAuthn is not enabled',
        severity: 'error',
        retryable: false,
      });
    }

    const storedChallenge = this.challenges.get(challengeId);
    if (!storedChallenge || storedChallenge.userId !== userId) {
      throw new AuthenticationError({
        code: 'auth/invalid_challenge',
        message: 'Invalid or expired challenge',
        severity: 'error',
        retryable: false,
      });
    }

    if (new Date() > storedChallenge.expiresAt) {
      this.challenges.delete(challengeId);
      throw new AuthenticationError({
        code: 'auth/challenge_expired',
        message: 'Challenge expired',
      });
    }

    // In production, verify the signature and authenticator data
    // This is a simplified version
    // const device = await this.storage.getWebAuthnDeviceByCredentialId(assertion.credentialId);
    // if (!device || device.userId !== userId) {
    //   throw new AuthenticationError('Invalid credential');
    // }

    // Verify signature and update counter
    // await this.storage.updateWebAuthnDevice(device.id, {
    //   counter: assertion.counter,
    //   lastUsedAt: new Date(),
    // });

    this.challenges.delete(challengeId);
    logger.info('WebAuthn authentication verified', { userId });

    // Return mock device for now
    return {
      id: 'device_123',
      userId,
      name: 'WebAuthn Device',
      credentialId: assertion.credentialId,
      publicKey: '',
      counter: 0,
      createdAt: new Date(),
      verified: true,
    };
  }

  /**
   * List WebAuthn devices for a user
   */
  async listDevices(_userId: string): Promise<WebAuthnDevice[]> {
    // In production, fetch from storage
    // return this.storage.listWebAuthnDevices(userId);
    return [];
  }

  /**
   * Delete a WebAuthn device
   */
  async deleteDevice(deviceId: string, userId: string): Promise<void> {
    // In production, delete from storage
    // await this.storage.deleteWebAuthnDevice(deviceId);
    logger.info('WebAuthn device deleted', { deviceId, userId });
  }

  /**
   * Clean up expired challenges
   */
  private cleanupExpiredChallenges(): void {
    const now = new Date();
    for (const [id, challenge] of this.challenges.entries()) {
      if (now > challenge.expiresAt) {
        this.challenges.delete(id);
      }
    }
  }
}

/**
 * WebAuthn/FIDO2 Types
 * Passwordless authentication using WebAuthn API
 */

/**
 * WebAuthn device/credential
 */
export interface WebAuthnDevice {
  id: string;
  userId: string;
  name: string;
  credentialId: string;
  publicKey: string;
  counter: number;
  transports?: AuthenticatorTransport[];
  createdAt: Date;
  lastUsedAt?: Date;
  verified: boolean;
}

/**
 * WebAuthn registration options
 */
export interface WebAuthnRegistrationOptions {
  challenge: string;
  rp: {
    name: string;
    id?: string;
  };
  user: {
    id: string;
    name: string;
    displayName: string;
  };
  pubKeyCredParams: Array<{
    type: 'public-key';
    alg: number;
  }>;
  timeout?: number;
  attestation?: 'none' | 'indirect' | 'direct';
  excludeCredentials?: Array<{
    id: string;
    type: 'public-key';
    transports?: AuthenticatorTransport[];
  }>;
  authenticatorSelection?: {
    authenticatorAttachment?: 'platform' | 'cross-platform';
    userVerification?: 'required' | 'preferred' | 'discouraged';
    requireResidentKey?: boolean;
  };
}

/**
 * WebAuthn authentication options
 */
export interface WebAuthnAuthenticationOptions {
  challenge: string;
  timeout?: number;
  rpId?: string;
  allowCredentials?: Array<{
    id: string;
    type: 'public-key';
    transports?: AuthenticatorTransport[];
  }>;
  userVerification?: 'required' | 'preferred' | 'discouraged';
}

/**
 * WebAuthn credential creation result
 */
export interface WebAuthnCredentialCreation {
  credentialId: string;
  publicKey: string;
  attestationObject: string;
  clientDataJSON: string;
  transports?: AuthenticatorTransport[];
}

/**
 * WebAuthn credential assertion result
 */
export interface WebAuthnCredentialAssertion {
  credentialId: string;
  authenticatorData: string;
  clientDataJSON: string;
  signature: string;
  userHandle?: string;
}

/**
 * WebAuthn configuration
 */
export interface WebAuthnConfig {
  enabled: boolean;
  rpName: string;
  rpId?: string;
  origin: string;
  timeout?: number;
  attestation?: 'none' | 'indirect' | 'direct';
  authenticatorSelection?: {
    authenticatorAttachment?: 'platform' | 'cross-platform';
    userVerification?: 'required' | 'preferred' | 'discouraged';
    requireResidentKey?: boolean;
  };
}

import { TwoFactorAuthService } from '../twofa/service';
import { ValidationError, AuthenticationError } from '../errors';

// Mock storage adapter
class MockStorageAdapter {
  private devices: Map<string, any> = new Map();
  private backupCodes: Map<string, any[]> = new Map();
  private sessions: Map<string, any> = new Map();

  async createTwoFactorDevice(data: any) {
    this.devices.set(data.id, data);
    return data;
  }

  async getTwoFactorDevice(deviceId: string) {
    return this.devices.get(deviceId) || null;
  }

  async updateTwoFactorDevice(deviceId: string, updates: any) {
    const device = this.devices.get(deviceId);
    if (!device) return null;
    const updated = { ...device, ...updates };
    this.devices.set(deviceId, updated);
    return updated;
  }

  async listTwoFactorDevices(userId: string) {
    return Array.from(this.devices.values()).filter((d) => d.userId === userId);
  }

  async deleteTwoFactorDevice(deviceId: string) {
    this.devices.delete(deviceId);
  }

  async createBackupCodes(userId: string, codes: any[]) {
    this.backupCodes.set(userId, codes);
    return codes;
  }

  async getBackupCodes(userId: string) {
    return this.backupCodes.get(userId) || [];
  }

  async markBackupCodeUsed(codeId: string) {
    for (const codes of this.backupCodes.values()) {
      const code = codes.find((c) => c.id === codeId);
      if (code) {
        code.used = true;
        code.usedAt = new Date();
      }
    }
  }

  async createTwoFactorSession(data: any) {
    this.sessions.set(data.id, data);
    return data;
  }

  async getTwoFactorSession(sessionId: string) {
    return this.sessions.get(sessionId) || null;
  }

  async completeTwoFactorSession(sessionId: string) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.completedAt = new Date();
    }
  }
}

describe('TwoFactorAuthService', () => {
  let twoFAService: TwoFactorAuthService;
  let mockStorage: MockStorageAdapter;

  beforeEach(() => {
    mockStorage = new MockStorageAdapter();
    twoFAService = new TwoFactorAuthService(mockStorage as any, {
      enabled: true,
      methods: ['totp', 'sms'],
      backup_codes_count: 10,
      totp: {
        issuer: 'Test App',
      },
    });
  });

  describe('TOTP Device Enrollment', () => {
    it('should enroll TOTP device', async () => {
      const device = await twoFAService.enrollTOTPDevice('user_1', 'My Phone');

      expect(device).toBeDefined();
      expect(device.method).toBe('totp');
      expect(device.verified).toBe(false);
      expect(device.name).toBe('My Phone');
      expect(device.qrCode).toBeDefined();
    });

    it('should throw error if TOTP method is disabled', async () => {
      const disabledService = new TwoFactorAuthService(mockStorage as any, {
        enabled: true,
        methods: ['sms'], // TOTP not enabled
      });

      await expect(disabledService.enrollTOTPDevice('user_1')).rejects.toThrow(ValidationError);
    });

    it('should throw error when 2FA is disabled', async () => {
      const disabledService = new TwoFactorAuthService(mockStorage as any, {
        enabled: false,
        methods: [],
      });

      await expect(disabledService.enrollTOTPDevice('user_1')).rejects.toThrow(ValidationError);
    });
  });

  describe('SMS Device Enrollment', () => {
    it('should enroll SMS device', async () => {
      const device = await twoFAService.enrollSMSDevice('user_1', '+1234567890', 'My Phone');

      expect(device).toBeDefined();
      expect(device.method).toBe('sms');
      expect(device.verified).toBe(false);
      expect(device.phoneNumber).toBe('+1234567890');
    });

    it('should throw error if phone number is missing', async () => {
      await expect(twoFAService.enrollSMSDevice('user_1', '', 'My Phone')).rejects.toThrow();
    });
  });

  describe('Device Management', () => {
    it('should get a device', async () => {
      const device = await twoFAService.enrollTOTPDevice('user_1');
      const retrieved = await twoFAService.getDevice(device.id);

      expect(retrieved).toBeDefined();
      expect(retrieved?.id).toBe(device.id);
    });

    it('should list user devices', async () => {
      await twoFAService.enrollTOTPDevice('user_1');
      await twoFAService.enrollSMSDevice('user_1', '+1234567890');

      const devices = await twoFAService.listDevices('user_1');

      expect(devices).toHaveLength(2);
      expect(devices.some((d) => d.method === 'totp')).toBe(true);
      expect(devices.some((d) => d.method === 'sms')).toBe(true);
    });

    it('should delete a device', async () => {
      const device = await twoFAService.enrollTOTPDevice('user_1');
      await twoFAService.deleteDevice(device.id);

      const retrieved = await twoFAService.getDevice(device.id);
      expect(retrieved).toBeNull();
    });
  });

  describe('2FA Status', () => {
    it('should report disabled 2FA when no devices', async () => {
      const status = await twoFAService.getTwoFactorStatus('user_1');

      expect(status.enabled).toBe(false);
      expect(status.devices).toHaveLength(0);
      expect(status.backupCodesCount).toBe(0);
    });

    it('should report enabled 2FA when devices exist', async () => {
      await twoFAService.enrollTOTPDevice('user_1');

      const status = await twoFAService.getTwoFactorStatus('user_1');

      expect(status.enabled).toBe(true);
      expect(status.devices).toHaveLength(1);
      expect(status.enrolledAt).toBeDefined();
    });
  });

  describe('2FA Sessions', () => {
    it('should create 2FA session', async () => {
      const device = await twoFAService.enrollTOTPDevice('user_1');
      const session = await twoFAService.createTwoFactorSession('user_1', 'session_1', device.id);

      expect(session).toBeDefined();
      expect(session.userId).toBe('user_1');
      expect(session.deviceId).toBe(device.id);
      expect(session.method).toBe('totp');
    });

    it('should complete 2FA session', async () => {
      const device = await twoFAService.enrollTOTPDevice('user_1');
      const session = await twoFAService.createTwoFactorSession('user_1', 'session_1', device.id);

      await twoFAService.completeTwoFactorSession(session.id);

      const retrieved = await twoFAService.getTwoFactorSession?.(session.id);
      expect(retrieved?.completedAt).toBeDefined();
    });
  });

  describe('Disable 2FA', () => {
    it('should disable 2FA and remove all devices', async () => {
      await twoFAService.enrollTOTPDevice('user_1');
      await twoFAService.enrollSMSDevice('user_1', '+1234567890');

      let devices = await twoFAService.listDevices('user_1');
      expect(devices).toHaveLength(2);

      await twoFAService.disableTwoFactor('user_1');

      devices = await twoFAService.listDevices('user_1');
      expect(devices).toHaveLength(0);
    });
  });

  describe('2FA Disabled', () => {
    it('should throw error when 2FA is disabled', async () => {
      const disabledService = new TwoFactorAuthService(mockStorage as any, {
        enabled: false,
        methods: [],
      });

      await expect(disabledService.enableTwoFactor('user_1')).rejects.toThrow(ValidationError);
    });
  });
});

import { RBACService } from '../rbac/service';
import { ValidationError, AuthorizationError } from '../errors';

// Mock storage adapter
class MockStorageAdapter {
  private roles: Map<string, any> = new Map();
  private userRoles: Map<string, string[]> = new Map();

  async createRole(data: any) {
    const role = { ...data, id: `role_${Math.random()}` };
    this.roles.set(role.id, role);
    return role;
  }

  async getRole(roleId: string) {
    return this.roles.get(roleId) || null;
  }

  async listRoles(orgId: string) {
    return Array.from(this.roles.values()).filter((r) => r.orgId === orgId);
  }

  async updateRole(roleId: string, updates: any) {
    const role = this.roles.get(roleId);
    if (!role) return null;
    const updated = { ...role, ...updates };
    this.roles.set(roleId, updated);
    return updated;
  }

  async deleteRole(roleId: string) {
    this.roles.delete(roleId);
  }

  async assignRoleToUser(userId: string, roleId: string, orgId: string) {
    const key = `${userId}_${orgId}`;
    const roles = this.userRoles.get(key) || [];
    if (!roles.includes(roleId)) {
      roles.push(roleId);
      this.userRoles.set(key, roles);
    }
  }

  async revokeRoleFromUser(userId: string, roleId: string, orgId: string) {
    const key = `${userId}_${orgId}`;
    const roles = this.userRoles.get(key) || [];
    this.userRoles.set(
      key,
      roles.filter((r) => r !== roleId)
    );
  }

  async getUserRoles(userId: string, orgId: string) {
    const key = `${userId}_${orgId}`;
    const roleIds = this.userRoles.get(key) || [];
    return roleIds.map((id) => this.roles.get(id)).filter(Boolean);
  }
}

describe('RBACService', () => {
  let rbacService: RBACService;
  let mockStorage: MockStorageAdapter;

  beforeEach(() => {
    mockStorage = new MockStorageAdapter();
    rbacService = new RBACService(mockStorage as any, { enabled: true });
  });

  describe('Role Management', () => {
    it('should create a new role', async () => {
      const role = await rbacService.createRole('org_1', 'Admin', [
        { id: 'perm_1', name: 'Full Access', resource: '*', action: '*' },
      ]);

      expect(role).toBeDefined();
      expect(role.name).toBe('Admin');
      expect(role.orgId).toBe('org_1');
      expect(role.permissions).toHaveLength(1);
    });

    it('should throw error if role name is empty', async () => {
      await expect(rbacService.createRole('org_1', '', [])).rejects.toThrow(ValidationError);
    });

    it('should get a role by ID', async () => {
      const created = await rbacService.createRole('org_1', 'Editor', []);
      const retrieved = await rbacService.getRole(created.id);

      expect(retrieved).toBeDefined();
      expect(retrieved?.name).toBe('Editor');
    });

    it('should list all roles in organization', async () => {
      await rbacService.createRole('org_1', 'Admin', []);
      await rbacService.createRole('org_1', 'Editor', []);
      await rbacService.createRole('org_2', 'Viewer', []);

      const roles = await rbacService.listRoles('org_1');

      expect(roles).toHaveLength(2);
      expect(roles.every((r) => r.orgId === 'org_1')).toBe(true);
    });

    it('should prevent modifying system roles', async () => {
      const role = await rbacService.createRole('org_1', 'Admin', []);
      await mockStorage.updateRole(role.id, { isSystem: true });

      await expect(rbacService.updateRole(role.id, { name: 'SuperAdmin' })).rejects.toThrow(
        AuthorizationError
      );
    });

    it('should prevent deleting system roles', async () => {
      const role = await rbacService.createRole('org_1', 'Admin', []);
      await mockStorage.updateRole(role.id, { isSystem: true });

      await expect(rbacService.deleteRole(role.id)).rejects.toThrow(AuthorizationError);
    });
  });

  describe('Role Assignment', () => {
    it('should assign role to user', async () => {
      const role = await rbacService.createRole('org_1', 'Editor', []);
      await rbacService.assignRoleToUser('user_1', role.id, 'org_1');

      const userRoles = await rbacService.getUserRoles('user_1', 'org_1');
      expect(userRoles).toHaveLength(1);
      expect(userRoles[0].id).toBe(role.id);
    });

    it('should revoke role from user', async () => {
      const role = await rbacService.createRole('org_1', 'Editor', []);
      await rbacService.assignRoleToUser('user_1', role.id, 'org_1');
      await rbacService.revokeRoleFromUser('user_1', role.id, 'org_1');

      const userRoles = await rbacService.getUserRoles('user_1', 'org_1');
      expect(userRoles).toHaveLength(0);
    });
  });

  describe('Permission Checking', () => {
    it('should check if user has permission', async () => {
      const role = await rbacService.createRole('org_1', 'Editor', [
        { id: 'perm_1', name: 'Write', resource: 'docs', action: 'write' },
      ]);

      await rbacService.assignRoleToUser('user_1', role.id, 'org_1');

      const hasPermission = await rbacService.hasPermission('user_1', {
        resource: 'docs',
        action: 'write',
        orgId: 'org_1',
      });

      expect(hasPermission).toBe(true);
    });

    it('should return false for missing permission', async () => {
      const role = await rbacService.createRole('org_1', 'Viewer', [
        { id: 'perm_1', name: 'Read', resource: 'docs', action: 'read' },
      ]);

      await rbacService.assignRoleToUser('user_1', role.id, 'org_1');

      const hasPermission = await rbacService.hasPermission('user_1', {
        resource: 'docs',
        action: 'delete',
        orgId: 'org_1',
      });

      expect(hasPermission).toBe(false);
    });

    it('should get all user permissions', async () => {
      const role = await rbacService.createRole('org_1', 'Admin', [
        { id: 'perm_1', name: 'Read', resource: 'docs', action: 'read' },
        { id: 'perm_2', name: 'Write', resource: 'docs', action: 'write' },
      ]);

      await rbacService.assignRoleToUser('user_1', role.id, 'org_1');

      const permissions = await rbacService.getUserPermissions('user_1', 'org_1');

      expect(permissions).toHaveLength(2);
      expect(permissions.some((p) => p.action === 'read')).toBe(true);
      expect(permissions.some((p) => p.action === 'write')).toBe(true);
    });

    it('should check any permission', async () => {
      const role = await rbacService.createRole('org_1', 'Editor', [
        { id: 'perm_1', name: 'Write', resource: 'docs', action: 'write' },
      ]);

      await rbacService.assignRoleToUser('user_1', role.id, 'org_1');

      const hasAny = await rbacService.hasAnyPermission('user_1', [
        { resource: 'docs', action: 'delete', orgId: 'org_1' },
        { resource: 'docs', action: 'write', orgId: 'org_1' },
      ]);

      expect(hasAny).toBe(true);
    });

    it('should check all permissions', async () => {
      const role = await rbacService.createRole('org_1', 'Editor', [
        { id: 'perm_1', name: 'Write', resource: 'docs', action: 'write' },
        { id: 'perm_2', name: 'Delete', resource: 'docs', action: 'delete' },
      ]);

      await rbacService.assignRoleToUser('user_1', role.id, 'org_1');

      const hasAll = await rbacService.hasAllPermissions('user_1', [
        { resource: 'docs', action: 'write', orgId: 'org_1' },
        { resource: 'docs', action: 'delete', orgId: 'org_1' },
      ]);

      expect(hasAll).toBe(true);
    });
  });

  describe('RBAC Disabled', () => {
    it('should throw error when RBAC is disabled', async () => {
      const disabledService = new RBACService(mockStorage as any, { enabled: false });

      await expect(disabledService.createRole('org_1', 'Admin', [])).rejects.toThrow(
        ValidationError
      );
    });
  });
});

import { SSOService } from '../sso/service';
import { ValidationError, NotFoundError } from '../errors';

// Mock storage adapter
class MockStorageAdapter {
  private providers: Map<string, any> = new Map();
  private ssoLinks: Map<string, any> = new Map();
  private ssoSessions: Map<string, any> = new Map();

  async createSSOProvider(data: any) {
    this.providers.set(data.id, data);
    return data;
  }

  async getSSOProvider(providerId: string) {
    return this.providers.get(providerId) || null;
  }

  async updateSSOProvider(providerId: string, updates: any) {
    const provider = this.providers.get(providerId);
    if (!provider) return null;
    const updated = { ...provider, ...updates };
    this.providers.set(providerId, updated);
    return updated;
  }

  async deleteSSOProvider(providerId: string) {
    this.providers.delete(providerId);
  }

  async listSSOProviders(orgId?: string) {
    return Array.from(this.providers.values()).filter((p) => !orgId || p.orgId === orgId);
  }

  async createSSOLink(data: any) {
    this.ssoLinks.set(data.id, data);
    return data;
  }

  async getSSOLink(linkId: string) {
    return this.ssoLinks.get(linkId) || null;
  }

  async getUserSSOLinks(userId: string) {
    return Array.from(this.ssoLinks.values()).filter((l) => l.userId === userId);
  }

  async deleteSSOLink(linkId: string) {
    this.ssoLinks.delete(linkId);
  }

  async createSSOSession(data: any) {
    this.ssoSessions.set(data.id, data);
    return data;
  }

  async getSSOSession(sessionId: string) {
    return this.ssoSessions.get(sessionId) || null;
  }
}

describe('SSOService', () => {
  let ssoService: SSOService;
  let mockStorage: MockStorageAdapter;

  beforeEach(() => {
    mockStorage = new MockStorageAdapter();
    ssoService = new SSOService(mockStorage as any, 'test-jwt-secret', {
      enabled: true,
      allowMultipleProviders: true,
      autoProvision: true,
      syncUserData: true,
    });
  });

  describe('OIDC Provider Management', () => {
    it('should register OIDC provider', async () => {
      const provider = await ssoService.registerOIDCProvider({
        name: 'Google',
        metadata_url: 'https://accounts.google.com/.well-known/openid-configuration',
        client_id: 'google-client-id',
        client_secret: 'google-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      expect(provider).toBeDefined();
      expect(provider.name).toBe('Google');
      expect(provider.type).toBe('oidc');
      expect(provider.client_id).toBe('google-client-id');
    });

    it('should throw error when SSO is disabled', async () => {
      const disabledService = new SSOService(mockStorage as any, 'secret', {
        enabled: false,
      });

      await expect(
        disabledService.registerOIDCProvider({
          name: 'Google',
          metadata_url: 'https://accounts.google.com/.well-known/openid-configuration',
          client_id: 'google-client-id',
          client_secret: 'google-client-secret',
          redirect_uris: ['http://localhost:3000/callback'],
          type: 'oidc',
        })
      ).rejects.toThrow(ValidationError);
    });

    it('should get OIDC provider by ID', async () => {
      const created = await ssoService.registerOIDCProvider({
        name: 'GitHub',
        metadata_url: 'https://github.com/.well-known/openid-configuration',
        client_id: 'github-client-id',
        client_secret: 'github-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      const retrieved = await ssoService.getProvider(created.id);

      expect(retrieved).toBeDefined();
      expect(retrieved?.name).toBe('GitHub');
    });

    it('should list OIDC providers', async () => {
      await ssoService.registerOIDCProvider({
        name: 'Google',
        metadata_url: 'https://accounts.google.com/.well-known/openid-configuration',
        client_id: 'google-client-id',
        client_secret: 'google-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      await ssoService.registerOIDCProvider({
        name: 'GitHub',
        metadata_url: 'https://github.com/.well-known/openid-configuration',
        client_id: 'github-client-id',
        client_secret: 'github-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      const providers = await ssoService.listProviders();

      expect(providers).toHaveLength(2);
    });

    it('should update OIDC provider', async () => {
      const provider = await ssoService.registerOIDCProvider({
        name: 'Google',
        metadata_url: 'https://accounts.google.com/.well-known/openid-configuration',
        client_id: 'google-client-id',
        client_secret: 'google-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      const updated = await ssoService.updateProvider(provider.id, {
        client_secret: 'new-secret',
      });

      expect(updated.client_secret).toBe('new-secret');
    });

    it('should delete OIDC provider', async () => {
      const provider = await ssoService.registerOIDCProvider({
        name: 'Google',
        metadata_url: 'https://accounts.google.com/.well-known/openid-configuration',
        client_id: 'google-client-id',
        client_secret: 'google-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      await ssoService.deleteProvider(provider.id);

      const retrieved = await ssoService.getProvider(provider.id);
      expect(retrieved).toBeNull();
    });
  });

  describe('SAML Provider Management', () => {
    it('should register SAML provider', async () => {
      const provider = await ssoService.registerSAMLProvider({
        name: 'Okta',
        idp_entity_id: 'https://okta.example.com/app/123/sso/saml',
        idp_sso_url: 'https://okta.example.com/app/123/sso/saml',
        sp_entity_id: 'http://localhost:3000/saml/metadata',
        sp_acs_url: 'http://localhost:3000/saml/acs',
        type: 'saml',
      });

      expect(provider).toBeDefined();
      expect(provider.name).toBe('Okta');
      expect(provider.type).toBe('saml');
    });
  });

  describe('SSO Links', () => {
    it('should link SSO provider to user', async () => {
      const provider = await ssoService.registerOIDCProvider({
        name: 'Google',
        metadata_url: 'https://accounts.google.com/.well-known/openid-configuration',
        client_id: 'google-client-id',
        client_secret: 'google-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      const link = await ssoService.linkSSOProvider(
        'user_1',
        provider.id,
        'google-subject-123',
        'user@example.com'
      );

      expect(link).toBeDefined();
      expect(link.userId).toBe('user_1');
      expect(link.providerId).toBe(provider.id);
      expect(link.providerSubject).toBe('google-subject-123');
    });

    it('should get user SSO links', async () => {
      const provider1 = await ssoService.registerOIDCProvider({
        name: 'Google',
        metadata_url: 'https://accounts.google.com/.well-known/openid-configuration',
        client_id: 'google-client-id',
        client_secret: 'google-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      const provider2 = await ssoService.registerOIDCProvider({
        name: 'GitHub',
        metadata_url: 'https://github.com/.well-known/openid-configuration',
        client_id: 'github-client-id',
        client_secret: 'github-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      await ssoService.linkSSOProvider('user_1', provider1.id, 'google-sub-123');
      await ssoService.linkSSOProvider('user_1', provider2.id, 'github-sub-456');

      const links = await ssoService.getUserSSOLinks('user_1');

      expect(links).toHaveLength(2);
      expect(links.some((l) => l.providerId === provider1.id)).toBe(true);
      expect(links.some((l) => l.providerId === provider2.id)).toBe(true);
    });

    it('should delete SSO link', async () => {
      const provider = await ssoService.registerOIDCProvider({
        name: 'Google',
        metadata_url: 'https://accounts.google.com/.well-known/openid-configuration',
        client_id: 'google-client-id',
        client_secret: 'google-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      const link = await ssoService.linkSSOProvider('user_1', provider.id, 'google-sub-123');
      await ssoService.deleteSSOLink(link.id);

      const links = await ssoService.getUserSSOLinks('user_1');
      expect(links).toHaveLength(0);
    });
  });

  describe('SSO Sessions', () => {
    it('should create SSO session', async () => {
      const provider = await ssoService.registerOIDCProvider({
        name: 'Google',
        metadata_url: 'https://accounts.google.com/.well-known/openid-configuration',
        client_id: 'google-client-id',
        client_secret: 'google-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      const session = await ssoService.createSSOSession('user_1', provider.id, 'google-sub-123');

      expect(session).toBeDefined();
      expect(session.userId).toBe('user_1');
      expect(session.providerId).toBe(provider.id);
    });

    it('should get SSO session', async () => {
      const provider = await ssoService.registerOIDCProvider({
        name: 'Google',
        metadata_url: 'https://accounts.google.com/.well-known/openid-configuration',
        client_id: 'google-client-id',
        client_secret: 'google-client-secret',
        redirect_uris: ['http://localhost:3000/callback'],
        type: 'oidc',
      });

      const session = await ssoService.createSSOSession('user_1', provider.id, 'google-sub-123');
      const retrieved = await ssoService.getSSOSession(session.id);

      expect(retrieved).toBeDefined();
      expect(retrieved?.userId).toBe('user_1');
    });
  });

  describe('Configuration', () => {
    it('should check if multiple providers allowed', () => {
      expect(ssoService.canLinkMultipleProviders()).toBe(true);
    });

    it('should check if auto-provisioning enabled', () => {
      expect(ssoService.isAutoProvisioningEnabled()).toBe(true);
    });

    it('should check if user data sync enabled', () => {
      expect(ssoService.isSyncUserDataEnabled()).toBe(true);
    });
  });
});

